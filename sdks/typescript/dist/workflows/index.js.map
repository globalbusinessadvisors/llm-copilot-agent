{"version":3,"sources":["../../src/client.ts","../../src/workflows/index.ts"],"names":[],"mappings":";;;;;AAyCO,IAAM,YAAA,GAAN,MAAM,aAAA,SAAqB,KAAA,CAAM;AAAA,EACtC,WAAA,CACE,OAAA,EACgB,IAAA,EACA,MAAA,EACA,SACA,SAAA,EAChB;AACA,IAAA,KAAA,CAAM,OAAO,CAAA;AALG,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA;AACA,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,IAAA,CAAA,OAAA,GAAA,OAAA;AACA,IAAA,IAAA,CAAA,SAAA,GAAA,SAAA;AAGhB,IAAA,IAAA,CAAK,IAAA,GAAO,cAAA;AAAA,EACd;AAAA,EAEA,OAAO,YAAA,CAAa,KAAA,EAAiB,MAAA,EAA+B;AAClE,IAAA,OAAO,IAAI,aAAA;AAAA,MACT,KAAA,CAAM,OAAA;AAAA,MACN,KAAA,CAAM,IAAA;AAAA,MACN,MAAA;AAAA,MACA,KAAA,CAAM,OAAA;AAAA,MACN,KAAA,CAAM;AAAA,KACR;AAAA,EACF;AACF,CAAA;;;AC/BO,IAAM,kBAAN,MAAsB;AAAA,EAC3B,YAA6B,MAAA,EAAoB;AAApB,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AAAA,EAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASlD,MAAM,OAAO,KAAA,EAAyD;AACpE,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,IAAA;AAAA,MACjC,mBAAA;AAAA,MACA;AAAA,KACF;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,2BAAA,EAA6B,eAAe,CAAA;AAAA,IACrE;AAEA,IAAA,OAAO,QAAA,CAAS,IAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,UAAA,EAAiD;AACzD,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,GAAA;AAAA,MACjC,qBAAqB,UAAU,CAAA;AAAA,KACjC;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,oBAAA,EAAsB,WAAA,EAAa,GAAG,CAAA;AAAA,IAC/D;AAEA,IAAA,OAAO,QAAA,CAAS,IAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KACJ,MAAA,EACgD;AAChD,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA;AAAA,MACjC,mBAAA;AAAA,MACA;AAAA,KACF;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,0BAAA,EAA4B,aAAa,CAAA;AAAA,IAClE;AAEA,IAAA,OAAO,QAAA,CAAS,IAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAA,CACJ,UAAA,EACA,OAAA,EAC6B;AAC7B,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,KAAA;AAAA,MACjC,qBAAqB,UAAU,CAAA,CAAA;AAAA,MAC/B;AAAA,KACF;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,2BAAA,EAA6B,eAAe,CAAA;AAAA,IACrE;AAEA,IAAA,OAAO,QAAA,CAAS,IAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,UAAA,EAAmC;AAC9C,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,MAAA;AAAA,MACjC,qBAAqB,UAAU,CAAA;AAAA,KACjC;AAEA,IAAA,IAAI,CAAC,SAAS,OAAA,EAAS;AACrB,MAAA,MAAM,IAAI,YAAA,CAAa,2BAAA,EAA6B,eAAe,CAAA;AAAA,IACrE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAA,CACJ,UAAA,EACA,WAAA,GAA2C,OAAA,EACd;AAC7B,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,IAAA;AAAA,MACjC,qBAAqB,UAAU,CAAA,SAAA,CAAA;AAAA,MAC/B,EAAE,WAAA;AAAY,KAChB;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA;AAAA,QACR,mCAAA;AAAA,QACA;AAAA,OACF;AAAA,IACF;AAEA,IAAA,OAAO,QAAA,CAAS,IAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aACJ,UAAA,EACgD;AAChD,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA;AAAA,MACjC,qBAAqB,UAAU,CAAA,SAAA;AAAA,KACjC;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA;AAAA,QACR,kCAAA;AAAA,QACA;AAAA,OACF;AAAA,IACF;AAEA,IAAA,OAAO,QAAA,CAAS,IAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,QAAQ,KAAA,EAAyD;AACrE,IAAA,MAAM,EAAE,UAAA,EAAY,GAAG,IAAA,EAAK,GAAI,KAAA;AAEhC,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,IAAA;AAAA,MACjC,qBAAqB,UAAU,CAAA,QAAA,CAAA;AAAA,MAC/B;AAAA,KACF;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,4BAAA,EAA8B,gBAAgB,CAAA;AAAA,IACvE;AAEA,IAAA,OAAO,IAAA,CAAK,cAAA,CAAe,QAAA,CAAS,IAAI,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAA,CACJ,KAAA,EACA,OAAA,GAEI,EAAC,EACuB;AAC5B,IAAA,MAAM,EAAE,UAAA,EAAY,GAAG,IAAA,EAAK,GAAI,KAAA;AAChC,IAAA,MAAM,EAAE,OAAA,EAAS,OAAA,EAAS,SAAS,UAAA,EAAY,MAAA,EAAQ,QAAO,GAAI,OAAA;AAElE,IAAA,IAAI,YAAwC,EAAC;AAE7C,IAAA,OAAO,IAAI,OAAA,CAA2B,CAAC,OAAA,EAAS,MAAA,KAAW;AACzD,MAAA,IAAA,CAAK,MAAA,CACF,MAAA;AAAA,QACC,qBAAqB,UAAU,CAAA,eAAA,CAAA;AAAA,QAC/B,EAAE,GAAG,IAAA,EAAM,MAAA,EAAQ,IAAA,EAAK;AAAA,QACxB;AAAA,UACE,OAAA,EAAS,CAAC,IAAA,KAAS;AACjB,YAAA,IAAI;AACF,cAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,IAAI,CAAA;AAE7B,cAAA,IAAI,KAAA,CAAM,SAAS,eAAA,EAAiB;AAClC,gBAAA,SAAA,GAAY,KAAA,CAAM,IAAA;AAAA,cACpB;AAEA,cAAA,MAAM,gBAAgB,KAAA,CAAM,IAAA;AAE5B,cAAA,QAAQ,cAAc,IAAA;AAAM,gBAC1B,KAAK,cAAA;AACH,kBAAA,OAAA,GAAU,CAAA,cAAA,EAAiB,aAAA,CAAc,MAAM,CAAA,CAAE,CAAA;AACjD,kBAAA;AAAA,gBAEF,KAAK,gBAAA;AACH,kBAAA,IAAI,aAAA,CAAc,MAAA,IAAU,aAAA,CAAc,MAAA,EAAQ;AAChD,oBAAA,MAAA,GAAS,aAAA,CAAc,MAAA,EAAQ,aAAA,CAAc,MAAM,CAAA;AAAA,kBACrD;AACA,kBAAA,OAAA,GAAU,CAAA,gBAAA,EAAmB,aAAA,CAAc,MAAM,CAAA,CAAE,CAAA;AACnD,kBAAA;AAAA,gBAEF,KAAK,aAAA;AACH,kBAAA,OAAA;AAAA,oBACE,CAAA,aAAA,EAAgB,aAAA,CAAc,MAAM,CAAA,GAAA,EAAM,cAAc,KAAK,CAAA;AAAA,mBAC/D;AACA,kBAAA;AAAA,gBAEF,KAAK,oBAAA;AACH,kBAAA;AAAA;AAGJ,cAAA,OAAA,GAAU,KAAK,CAAA;AAAA,YACjB,CAAA,CAAA,MAAQ;AACN,cAAA,OAAA,GAAU,IAAI,CAAA;AAAA,YAChB;AAAA,UACF,CAAA;AAAA,UACA,OAAA,EAAS,CAAC,KAAA,KAAU;AAClB,YAAA,OAAA,GAAU,KAAK,CAAA;AACf,YAAA,MAAA,CAAO,KAAK,CAAA;AAAA,UACd,CAAA;AAAA,UACA,YAAY,MAAM;AAChB,YAAA,MAAM,iBAAiB,IAAA,CAAK,cAAA;AAAA,cAC1B;AAAA,aACF;AACA,YAAA,UAAA,GAAa,cAAuB,CAAA;AACpC,YAAA,OAAA,CAAQ,cAAc,CAAA;AAAA,UACxB;AAAA,SACF;AAAA,QACA;AAAA,OACF,CACC,MAAM,MAAM,CAAA;AAAA,IACjB,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,WAAA,EAAiD;AAClE,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,GAAA;AAAA,MACjC,sBAAsB,WAAW,CAAA;AAAA,KACnC;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,qBAAA,EAAuB,WAAA,EAAa,GAAG,CAAA;AAAA,IAChE;AAEA,IAAA,OAAO,IAAA,CAAK,cAAA,CAAe,QAAA,CAAS,IAAI,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAA,CACJ,UAAA,EACA,MAAA,EAC+C;AAC/C,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA;AAAA,MACjC,qBAAqB,UAAU,CAAA,WAAA,CAAA;AAAA,MAC/B;AAAA,KACF;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,2BAAA,EAA6B,aAAa,CAAA;AAAA,IACnE;AAEA,IAAA,OAAO;AAAA,MACL,GAAG,QAAA,CAAS,IAAA;AAAA,MACZ,KAAA,EAAO,QAAA,CAAS,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,CAAC,CAAA,KAAM,IAAA,CAAK,cAAA,CAAe,CAAC,CAAC;AAAA,KAC9D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,WAAA,EAAiD;AACrE,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,IAAA;AAAA,MACjC,sBAAsB,WAAW,CAAA,OAAA;AAAA,KACnC;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,4BAAA,EAA8B,eAAe,CAAA;AAAA,IACtE;AAEA,IAAA,OAAO,IAAA,CAAK,cAAA,CAAe,QAAA,CAAS,IAAI,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAA,CACJ,WAAA,EACA,QAAA,EAC4B;AAC5B,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,IAAA;AAAA,MACjC,sBAAsB,WAAW,CAAA,MAAA,CAAA;AAAA,MACjC,EAAE,QAAA;AAAS,KACb;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,2BAAA,EAA6B,cAAc,CAAA;AAAA,IACpE;AAEA,IAAA,OAAO,IAAA,CAAK,cAAA,CAAe,QAAA,CAAS,IAAI,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,WAAA,EAAiD;AACpE,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,IAAA;AAAA,MACjC,sBAAsB,WAAW,CAAA,MAAA;AAAA,KACnC;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,2BAAA,EAA6B,cAAc,CAAA;AAAA,IACpE;AAEA,IAAA,OAAO,IAAA,CAAK,cAAA,CAAe,QAAA,CAAS,IAAI,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,WAAA,EAAiD;AACrE,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,IAAA;AAAA,MACjC,sBAAsB,WAAW,CAAA,OAAA;AAAA,KACnC;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,4BAAA,EAA8B,eAAe,CAAA;AAAA,IACtE;AAEA,IAAA,OAAO,IAAA,CAAK,cAAA,CAAe,QAAA,CAAS,IAAI,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAA,CACJ,WAAA,EACA,OAAA,GAII,EAAC,EACuB;AAC5B,IAAA,MAAM,EAAE,YAAA,GAAe,GAAA,EAAM,OAAA,GAAU,GAAA,EAAQ,YAAW,GAAI,OAAA;AAC9D,IAAA,MAAM,SAAA,GAAY,KAAK,GAAA,EAAI;AAE3B,IAAA,OAAO,IAAA,EAAM;AACX,MAAA,MAAM,SAAA,GAAY,MAAM,IAAA,CAAK,YAAA,CAAa,WAAW,CAAA;AAErD,MAAA,UAAA,GAAa,SAAS,CAAA;AAEtB,MAAA,IACE,SAAA,CAAU,WAAW,WAAA,IACrB,SAAA,CAAU,WAAW,QAAA,IACrB,SAAA,CAAU,WAAW,WAAA,EACrB;AACA,QAAA,OAAO,SAAA;AAAA,MACT;AAEA,MAAA,IAAI,IAAA,CAAK,GAAA,EAAI,GAAI,SAAA,GAAY,OAAA,EAAS;AACpC,QAAA,MAAM,IAAI,YAAA;AAAA,UACR,4BAAA;AAAA,UACA;AAAA,SACF;AAAA,MACF;AAEA,MAAA,MAAM,IAAI,OAAA,CAAQ,CAAC,YAAY,UAAA,CAAW,OAAA,EAAS,YAAY,CAAC,CAAA;AAAA,IAClE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,kBAAA,CACJ,UAAA,EACA,MAAA,EAC6B;AAC7B,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,IAAA;AAAA,MACjC,+BAA+B,UAAU,CAAA,YAAA,CAAA;AAAA,MACzC;AAAA,KACF;AAEA,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA;AAAA,QACR,yCAAA;AAAA,QACA;AAAA,OACF;AAAA,IACF;AAEA,IAAA,OAAO,QAAA,CAAS,IAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAA,GAEJ;AACA,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,SAIhC,6BAA6B,CAAA;AAEhC,IAAA,IAAI,CAAC,QAAA,CAAS,OAAA,IAAW,CAAC,SAAS,IAAA,EAAM;AACvC,MAAA,MAAM,IAAI,YAAA,CAAa,0BAAA,EAA4B,uBAAuB,CAAA;AAAA,IAC5E;AAEA,IAAA,OAAO,QAAA,CAAS,IAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,IAAA,EAA4C;AACjE,IAAA,OAAO;AAAA,MACL,GAAG,IAAA;AAAA,MACH,SAAA,EAAW,IAAI,IAAA,CAAK,IAAA,CAAK,SAAS,CAAA;AAAA,MAClC,SAAA,EAAW,IAAI,IAAA,CAAK,IAAA,CAAK,SAAS,CAAA;AAAA,MAClC,WAAW,IAAA,CAAK,SAAA,GAAY,IAAI,IAAA,CAAK,IAAA,CAAK,SAAS,CAAA,GAAI,MAAA;AAAA,MACvD,aAAa,IAAA,CAAK,WAAA,GAAc,IAAI,IAAA,CAAK,IAAA,CAAK,WAAW,CAAA,GAAI;AAAA,KAC/D;AAAA,EACF;AACF;AAEA,IAAO,iBAAA,GAAQ","file":"index.js","sourcesContent":["/**\n * HTTP Client for LLM-CoPilot SDK\n */\n\nimport type {\n  CopilotConfig,\n  ApiResponse,\n  ApiError,\n  PaginationParams,\n  PaginatedResponse,\n} from './types';\n\n/**\n * HTTP method types\n */\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n\n/**\n * Request options\n */\ninterface RequestOptions<T = unknown> {\n  method?: HttpMethod;\n  body?: T;\n  query?: Record<string, string | number | boolean | undefined>;\n  headers?: Record<string, string>;\n  signal?: AbortSignal;\n  timeout?: number;\n}\n\n/**\n * Stream response handler\n */\ninterface StreamHandler {\n  onChunk: (chunk: string) => void;\n  onError?: (error: Error) => void;\n  onComplete?: () => void;\n}\n\n/**\n * SDK Error class\n */\nexport class CopilotError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly status?: number,\n    public readonly details?: Record<string, unknown>,\n    public readonly requestId?: string\n  ) {\n    super(message);\n    this.name = 'CopilotError';\n  }\n\n  static fromApiError(error: ApiError, status?: number): CopilotError {\n    return new CopilotError(\n      error.message,\n      error.code,\n      status,\n      error.details,\n      error.requestId\n    );\n  }\n}\n\n/**\n * HTTP Client for making API requests\n */\nexport class HttpClient {\n  private readonly config: Required<\n    Pick<CopilotConfig, 'baseUrl' | 'apiKey' | 'timeout' | 'maxRetries'>\n  > &\n    Pick<CopilotConfig, 'tenantId' | 'headers' | 'debug'>;\n\n  constructor(config: CopilotConfig) {\n    this.config = {\n      baseUrl: config.baseUrl.replace(/\\/+$/, ''),\n      apiKey: config.apiKey,\n      timeout: config.timeout ?? 30000,\n      maxRetries: config.maxRetries ?? 3,\n      tenantId: config.tenantId,\n      headers: config.headers,\n      debug: config.debug,\n    };\n  }\n\n  /**\n   * Build full URL with query parameters\n   */\n  private buildUrl(\n    path: string,\n    query?: Record<string, string | number | boolean | undefined>\n  ): string {\n    const url = new URL(path, this.config.baseUrl);\n\n    if (query) {\n      Object.entries(query).forEach(([key, value]) => {\n        if (value !== undefined) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    return url.toString();\n  }\n\n  /**\n   * Build request headers\n   */\n  private buildHeaders(customHeaders?: Record<string, string>): Headers {\n    const headers = new Headers({\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${this.config.apiKey}`,\n      'User-Agent': '@llm-copilot/sdk',\n      ...this.config.headers,\n      ...customHeaders,\n    });\n\n    if (this.config.tenantId) {\n      headers.set('X-Tenant-ID', this.config.tenantId);\n    }\n\n    return headers;\n  }\n\n  /**\n   * Log debug information\n   */\n  private debug(message: string, data?: unknown): void {\n    if (this.config.debug) {\n      console.log(`[CopilotSDK] ${message}`, data ?? '');\n    }\n  }\n\n  /**\n   * Execute a request with retry logic\n   */\n  private async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    retries: number = this.config.maxRetries\n  ): Promise<T> {\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error as Error;\n\n        // Don't retry on client errors (4xx) except 429 (rate limit)\n        if (error instanceof CopilotError) {\n          if (\n            error.status &&\n            error.status >= 400 &&\n            error.status < 500 &&\n            error.status !== 429\n          ) {\n            throw error;\n          }\n        }\n\n        if (attempt < retries) {\n          const delay = Math.min(1000 * Math.pow(2, attempt), 10000);\n          this.debug(`Retry attempt ${attempt + 1} after ${delay}ms`);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Make an HTTP request\n   */\n  async request<T, B = unknown>(\n    path: string,\n    options: RequestOptions<B> = {}\n  ): Promise<ApiResponse<T>> {\n    const { method = 'GET', body, query, headers, signal, timeout } = options;\n\n    const url = this.buildUrl(path, query);\n    const requestHeaders = this.buildHeaders(headers);\n\n    this.debug(`${method} ${url}`);\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(\n      () => controller.abort(),\n      timeout ?? this.config.timeout\n    );\n\n    try {\n      const response = await this.executeWithRetry(async () => {\n        const res = await fetch(url, {\n          method,\n          headers: requestHeaders,\n          body: body ? JSON.stringify(body) : undefined,\n          signal: signal ?? controller.signal,\n        });\n\n        if (!res.ok) {\n          const errorBody = await res.json().catch(() => ({}));\n          const apiError: ApiError = {\n            code: errorBody.code ?? 'UNKNOWN_ERROR',\n            message: errorBody.message ?? res.statusText,\n            details: errorBody.details,\n            requestId: res.headers.get('X-Request-ID') ?? undefined,\n          };\n          throw CopilotError.fromApiError(apiError, res.status);\n        }\n\n        return res;\n      });\n\n      const data = await response.json();\n\n      return {\n        success: true,\n        data: data as T,\n        metadata: {\n          requestId: response.headers.get('X-Request-ID') ?? '',\n          processingTimeMs: parseInt(\n            response.headers.get('X-Processing-Time') ?? '0',\n            10\n          ),\n          rateLimit: this.parseRateLimitHeaders(response.headers),\n        },\n      };\n    } catch (error) {\n      if (error instanceof CopilotError) {\n        throw error;\n      }\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new CopilotError('Request timeout', 'TIMEOUT', 408);\n      }\n\n      throw new CopilotError(\n        error instanceof Error ? error.message : 'Unknown error',\n        'NETWORK_ERROR'\n      );\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  /**\n   * Parse rate limit headers from response\n   */\n  private parseRateLimitHeaders(\n    headers: Headers\n  ): { limit: number; remaining: number; resetAt: Date } | undefined {\n    const limit = headers.get('X-RateLimit-Limit');\n    const remaining = headers.get('X-RateLimit-Remaining');\n    const reset = headers.get('X-RateLimit-Reset');\n\n    if (limit && remaining && reset) {\n      return {\n        limit: parseInt(limit, 10),\n        remaining: parseInt(remaining, 10),\n        resetAt: new Date(parseInt(reset, 10) * 1000),\n      };\n    }\n\n    return undefined;\n  }\n\n  /**\n   * GET request\n   */\n  async get<T>(\n    path: string,\n    query?: Record<string, string | number | boolean | undefined>,\n    options?: Omit<RequestOptions, 'method' | 'body' | 'query'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T>(path, { ...options, method: 'GET', query });\n  }\n\n  /**\n   * POST request\n   */\n  async post<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'POST', body });\n  }\n\n  /**\n   * PUT request\n   */\n  async put<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'PUT', body });\n  }\n\n  /**\n   * PATCH request\n   */\n  async patch<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'PATCH', body });\n  }\n\n  /**\n   * DELETE request\n   */\n  async delete<T>(\n    path: string,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T>(path, { ...options, method: 'DELETE' });\n  }\n\n  /**\n   * Stream request using Server-Sent Events\n   */\n  async stream(\n    path: string,\n    body: unknown,\n    handler: StreamHandler,\n    signal?: AbortSignal\n  ): Promise<void> {\n    const url = this.buildUrl(path);\n    const headers = this.buildHeaders({ Accept: 'text/event-stream' });\n\n    this.debug(`STREAM ${url}`);\n\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(body),\n        signal,\n      });\n\n      if (!response.ok) {\n        const errorBody = await response.json().catch(() => ({}));\n        throw CopilotError.fromApiError(\n          {\n            code: errorBody.code ?? 'STREAM_ERROR',\n            message: errorBody.message ?? response.statusText,\n          },\n          response.status\n        );\n      }\n\n      if (!response.body) {\n        throw new CopilotError('No response body', 'NO_BODY', 500);\n      }\n\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            handler.onComplete?.();\n            break;\n          }\n\n          const chunk = decoder.decode(value, { stream: true });\n          const lines = chunk.split('\\n');\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              const data = line.slice(6);\n              if (data === '[DONE]') {\n                handler.onComplete?.();\n                return;\n              }\n              handler.onChunk(data);\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    } catch (error) {\n      if (error instanceof CopilotError) {\n        handler.onError?.(error);\n        throw error;\n      }\n\n      const copilotError = new CopilotError(\n        error instanceof Error ? error.message : 'Stream error',\n        'STREAM_ERROR'\n      );\n      handler.onError?.(copilotError);\n      throw copilotError;\n    }\n  }\n\n  /**\n   * Paginated GET request\n   */\n  async paginate<T>(\n    path: string,\n    params?: PaginationParams & Record<string, unknown>\n  ): Promise<ApiResponse<PaginatedResponse<T>>> {\n    const { page = 1, pageSize = 20, cursor, ...rest } = params ?? {};\n\n    return this.get<PaginatedResponse<T>>(path, {\n      page,\n      page_size: pageSize,\n      cursor,\n      ...rest,\n    });\n  }\n\n  /**\n   * Iterate through all pages\n   */\n  async *paginateAll<T>(\n    path: string,\n    params?: Omit<PaginationParams, 'page' | 'cursor'> &\n      Record<string, unknown>\n  ): AsyncGenerator<T, void, unknown> {\n    let cursor: string | undefined;\n    let hasMore = true;\n\n    while (hasMore) {\n      const response = await this.paginate<T>(path, { ...params, cursor });\n\n      if (!response.success || !response.data) {\n        throw new CopilotError('Pagination failed', 'PAGINATION_ERROR');\n      }\n\n      for (const item of response.data.items) {\n        yield item;\n      }\n\n      hasMore = response.data.hasMore;\n      cursor = response.data.nextCursor;\n    }\n  }\n}\n\nexport { HttpClient as default };\n","/**\n * Workflows API client\n */\n\nimport { HttpClient, CopilotError } from '../client';\nimport type {\n  WorkflowDefinition,\n  WorkflowExecution,\n  CreateWorkflowInput,\n  ExecuteWorkflowInput,\n  WorkflowStatus,\n  StepResult,\n  PaginatedResponse,\n  PaginationParams,\n  StreamOptions,\n  StreamEvent,\n} from '../types';\n\n/**\n * Workflow execution event\n */\ninterface WorkflowEvent {\n  type: 'step_started' | 'step_completed' | 'step_failed' | 'workflow_completed';\n  stepId?: string;\n  result?: StepResult;\n  error?: string;\n}\n\n/**\n * Workflows API client\n */\nexport class WorkflowsClient {\n  constructor(private readonly client: HttpClient) {}\n\n  // ============================================================================\n  // Workflow Definitions\n  // ============================================================================\n\n  /**\n   * Create a new workflow\n   */\n  async create(input: CreateWorkflowInput): Promise<WorkflowDefinition> {\n    const response = await this.client.post<WorkflowDefinition>(\n      '/api/v1/workflows',\n      input\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to create workflow', 'CREATE_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Get a workflow by ID\n   */\n  async get(workflowId: string): Promise<WorkflowDefinition> {\n    const response = await this.client.get<WorkflowDefinition>(\n      `/api/v1/workflows/${workflowId}`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Workflow not found', 'NOT_FOUND', 404);\n    }\n\n    return response.data;\n  }\n\n  /**\n   * List workflows\n   */\n  async list(\n    params?: PaginationParams\n  ): Promise<PaginatedResponse<WorkflowDefinition>> {\n    const response = await this.client.paginate<WorkflowDefinition>(\n      '/api/v1/workflows',\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list workflows', 'LIST_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Update a workflow\n   */\n  async update(\n    workflowId: string,\n    updates: Partial<CreateWorkflowInput>\n  ): Promise<WorkflowDefinition> {\n    const response = await this.client.patch<WorkflowDefinition>(\n      `/api/v1/workflows/${workflowId}`,\n      updates\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to update workflow', 'UPDATE_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Delete a workflow\n   */\n  async delete(workflowId: string): Promise<void> {\n    const response = await this.client.delete(\n      `/api/v1/workflows/${workflowId}`\n    );\n\n    if (!response.success) {\n      throw new CopilotError('Failed to delete workflow', 'DELETE_FAILED');\n    }\n  }\n\n  /**\n   * Create a new version of a workflow\n   */\n  async createVersion(\n    workflowId: string,\n    versionType: 'major' | 'minor' | 'patch' = 'minor'\n  ): Promise<WorkflowDefinition> {\n    const response = await this.client.post<WorkflowDefinition>(\n      `/api/v1/workflows/${workflowId}/versions`,\n      { versionType }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to create workflow version',\n        'VERSION_FAILED'\n      );\n    }\n\n    return response.data;\n  }\n\n  /**\n   * List workflow versions\n   */\n  async listVersions(\n    workflowId: string\n  ): Promise<PaginatedResponse<WorkflowDefinition>> {\n    const response = await this.client.paginate<WorkflowDefinition>(\n      `/api/v1/workflows/${workflowId}/versions`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to list workflow versions',\n        'LIST_VERSIONS_FAILED'\n      );\n    }\n\n    return response.data;\n  }\n\n  // ============================================================================\n  // Workflow Execution\n  // ============================================================================\n\n  /**\n   * Execute a workflow\n   */\n  async execute(input: ExecuteWorkflowInput): Promise<WorkflowExecution> {\n    const { workflowId, ...rest } = input;\n\n    const response = await this.client.post<WorkflowExecution>(\n      `/api/v1/workflows/${workflowId}/execute`,\n      rest\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to execute workflow', 'EXECUTE_FAILED');\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * Execute a workflow and stream progress\n   */\n  async executeWithStream(\n    input: ExecuteWorkflowInput,\n    options: StreamOptions & {\n      onStep?: (stepId: string, result: StepResult) => void;\n    } = {}\n  ): Promise<WorkflowExecution> {\n    const { workflowId, ...rest } = input;\n    const { onChunk, onEvent, onError, onComplete, onStep, signal } = options;\n\n    let execution: Partial<WorkflowExecution> = {};\n\n    return new Promise<WorkflowExecution>((resolve, reject) => {\n      this.client\n        .stream(\n          `/api/v1/workflows/${workflowId}/execute/stream`,\n          { ...rest, stream: true },\n          {\n            onChunk: (data) => {\n              try {\n                const event = JSON.parse(data) as StreamEvent<WorkflowEvent>;\n\n                if (event.type === 'message_start') {\n                  execution = event.data as Partial<WorkflowExecution>;\n                }\n\n                const workflowEvent = event.data as WorkflowEvent;\n\n                switch (workflowEvent.type) {\n                  case 'step_started':\n                    onChunk?.(`Step started: ${workflowEvent.stepId}`);\n                    break;\n\n                  case 'step_completed':\n                    if (workflowEvent.stepId && workflowEvent.result) {\n                      onStep?.(workflowEvent.stepId, workflowEvent.result);\n                    }\n                    onChunk?.(`Step completed: ${workflowEvent.stepId}`);\n                    break;\n\n                  case 'step_failed':\n                    onChunk?.(\n                      `Step failed: ${workflowEvent.stepId} - ${workflowEvent.error}`\n                    );\n                    break;\n\n                  case 'workflow_completed':\n                    break;\n                }\n\n                onEvent?.(event);\n              } catch {\n                onChunk?.(data);\n              }\n            },\n            onError: (error) => {\n              onError?.(error);\n              reject(error);\n            },\n            onComplete: () => {\n              const finalExecution = this.parseExecution(\n                execution as WorkflowExecution\n              );\n              onComplete?.(finalExecution as never);\n              resolve(finalExecution);\n            },\n          },\n          signal\n        )\n        .catch(reject);\n    });\n  }\n\n  /**\n   * Get execution status\n   */\n  async getExecution(executionId: string): Promise<WorkflowExecution> {\n    const response = await this.client.get<WorkflowExecution>(\n      `/api/v1/executions/${executionId}`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Execution not found', 'NOT_FOUND', 404);\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * List executions for a workflow\n   */\n  async listExecutions(\n    workflowId: string,\n    params?: PaginationParams & { status?: WorkflowStatus }\n  ): Promise<PaginatedResponse<WorkflowExecution>> {\n    const response = await this.client.paginate<WorkflowExecution>(\n      `/api/v1/workflows/${workflowId}/executions`,\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list executions', 'LIST_FAILED');\n    }\n\n    return {\n      ...response.data,\n      items: response.data.items.map((e) => this.parseExecution(e)),\n    };\n  }\n\n  /**\n   * Cancel a running execution\n   */\n  async cancelExecution(executionId: string): Promise<WorkflowExecution> {\n    const response = await this.client.post<WorkflowExecution>(\n      `/api/v1/executions/${executionId}/cancel`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to cancel execution', 'CANCEL_FAILED');\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * Retry a failed execution\n   */\n  async retryExecution(\n    executionId: string,\n    fromStep?: string\n  ): Promise<WorkflowExecution> {\n    const response = await this.client.post<WorkflowExecution>(\n      `/api/v1/executions/${executionId}/retry`,\n      { fromStep }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to retry execution', 'RETRY_FAILED');\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * Pause a running execution\n   */\n  async pauseExecution(executionId: string): Promise<WorkflowExecution> {\n    const response = await this.client.post<WorkflowExecution>(\n      `/api/v1/executions/${executionId}/pause`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to pause execution', 'PAUSE_FAILED');\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * Resume a paused execution\n   */\n  async resumeExecution(executionId: string): Promise<WorkflowExecution> {\n    const response = await this.client.post<WorkflowExecution>(\n      `/api/v1/executions/${executionId}/resume`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to resume execution', 'RESUME_FAILED');\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * Poll execution until completion\n   */\n  async waitForCompletion(\n    executionId: string,\n    options: {\n      pollInterval?: number;\n      timeout?: number;\n      onProgress?: (execution: WorkflowExecution) => void;\n    } = {}\n  ): Promise<WorkflowExecution> {\n    const { pollInterval = 1000, timeout = 300000, onProgress } = options;\n    const startTime = Date.now();\n\n    while (true) {\n      const execution = await this.getExecution(executionId);\n\n      onProgress?.(execution);\n\n      if (\n        execution.status === 'completed' ||\n        execution.status === 'failed' ||\n        execution.status === 'cancelled'\n      ) {\n        return execution;\n      }\n\n      if (Date.now() - startTime > timeout) {\n        throw new CopilotError(\n          'Workflow execution timeout',\n          'EXECUTION_TIMEOUT'\n        );\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, pollInterval));\n    }\n  }\n\n  // ============================================================================\n  // Templates\n  // ============================================================================\n\n  /**\n   * Create workflow from template\n   */\n  async createFromTemplate(\n    templateId: string,\n    params: Record<string, unknown>\n  ): Promise<WorkflowDefinition> {\n    const response = await this.client.post<WorkflowDefinition>(\n      `/api/v1/workflows/templates/${templateId}/instantiate`,\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to create workflow from template',\n        'TEMPLATE_FAILED'\n      );\n    }\n\n    return response.data;\n  }\n\n  /**\n   * List available templates\n   */\n  async listTemplates(): Promise<\n    PaginatedResponse<{ id: string; name: string; description: string }>\n  > {\n    const response = await this.client.paginate<{\n      id: string;\n      name: string;\n      description: string;\n    }>('/api/v1/workflows/templates');\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list templates', 'LIST_TEMPLATES_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Parse execution response to ensure proper types\n   */\n  private parseExecution(data: WorkflowExecution): WorkflowExecution {\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      updatedAt: new Date(data.updatedAt),\n      startedAt: data.startedAt ? new Date(data.startedAt) : undefined,\n      completedAt: data.completedAt ? new Date(data.completedAt) : undefined,\n    };\n  }\n}\n\nexport default WorkflowsClient;\n"]}