{"version":3,"sources":["../../src/client.ts","../../src/context/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * HTTP Client for LLM-CoPilot SDK\n */\n\nimport type {\n  CopilotConfig,\n  ApiResponse,\n  ApiError,\n  PaginationParams,\n  PaginatedResponse,\n} from './types';\n\n/**\n * HTTP method types\n */\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n\n/**\n * Request options\n */\ninterface RequestOptions<T = unknown> {\n  method?: HttpMethod;\n  body?: T;\n  query?: Record<string, string | number | boolean | undefined>;\n  headers?: Record<string, string>;\n  signal?: AbortSignal;\n  timeout?: number;\n}\n\n/**\n * Stream response handler\n */\ninterface StreamHandler {\n  onChunk: (chunk: string) => void;\n  onError?: (error: Error) => void;\n  onComplete?: () => void;\n}\n\n/**\n * SDK Error class\n */\nexport class CopilotError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly status?: number,\n    public readonly details?: Record<string, unknown>,\n    public readonly requestId?: string\n  ) {\n    super(message);\n    this.name = 'CopilotError';\n  }\n\n  static fromApiError(error: ApiError, status?: number): CopilotError {\n    return new CopilotError(\n      error.message,\n      error.code,\n      status,\n      error.details,\n      error.requestId\n    );\n  }\n}\n\n/**\n * HTTP Client for making API requests\n */\nexport class HttpClient {\n  private readonly config: Required<\n    Pick<CopilotConfig, 'baseUrl' | 'apiKey' | 'timeout' | 'maxRetries'>\n  > &\n    Pick<CopilotConfig, 'tenantId' | 'headers' | 'debug'>;\n\n  constructor(config: CopilotConfig) {\n    this.config = {\n      baseUrl: config.baseUrl.replace(/\\/+$/, ''),\n      apiKey: config.apiKey,\n      timeout: config.timeout ?? 30000,\n      maxRetries: config.maxRetries ?? 3,\n      tenantId: config.tenantId,\n      headers: config.headers,\n      debug: config.debug,\n    };\n  }\n\n  /**\n   * Build full URL with query parameters\n   */\n  private buildUrl(\n    path: string,\n    query?: Record<string, string | number | boolean | undefined>\n  ): string {\n    const url = new URL(path, this.config.baseUrl);\n\n    if (query) {\n      Object.entries(query).forEach(([key, value]) => {\n        if (value !== undefined) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    return url.toString();\n  }\n\n  /**\n   * Build request headers\n   */\n  private buildHeaders(customHeaders?: Record<string, string>): Headers {\n    const headers = new Headers({\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${this.config.apiKey}`,\n      'User-Agent': '@llm-copilot/sdk',\n      ...this.config.headers,\n      ...customHeaders,\n    });\n\n    if (this.config.tenantId) {\n      headers.set('X-Tenant-ID', this.config.tenantId);\n    }\n\n    return headers;\n  }\n\n  /**\n   * Log debug information\n   */\n  private debug(message: string, data?: unknown): void {\n    if (this.config.debug) {\n      console.log(`[CopilotSDK] ${message}`, data ?? '');\n    }\n  }\n\n  /**\n   * Execute a request with retry logic\n   */\n  private async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    retries: number = this.config.maxRetries\n  ): Promise<T> {\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error as Error;\n\n        // Don't retry on client errors (4xx) except 429 (rate limit)\n        if (error instanceof CopilotError) {\n          if (\n            error.status &&\n            error.status >= 400 &&\n            error.status < 500 &&\n            error.status !== 429\n          ) {\n            throw error;\n          }\n        }\n\n        if (attempt < retries) {\n          const delay = Math.min(1000 * Math.pow(2, attempt), 10000);\n          this.debug(`Retry attempt ${attempt + 1} after ${delay}ms`);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Make an HTTP request\n   */\n  async request<T, B = unknown>(\n    path: string,\n    options: RequestOptions<B> = {}\n  ): Promise<ApiResponse<T>> {\n    const { method = 'GET', body, query, headers, signal, timeout } = options;\n\n    const url = this.buildUrl(path, query);\n    const requestHeaders = this.buildHeaders(headers);\n\n    this.debug(`${method} ${url}`);\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(\n      () => controller.abort(),\n      timeout ?? this.config.timeout\n    );\n\n    try {\n      const response = await this.executeWithRetry(async () => {\n        const res = await fetch(url, {\n          method,\n          headers: requestHeaders,\n          body: body ? JSON.stringify(body) : undefined,\n          signal: signal ?? controller.signal,\n        });\n\n        if (!res.ok) {\n          const errorBody = await res.json().catch(() => ({}));\n          const apiError: ApiError = {\n            code: errorBody.code ?? 'UNKNOWN_ERROR',\n            message: errorBody.message ?? res.statusText,\n            details: errorBody.details,\n            requestId: res.headers.get('X-Request-ID') ?? undefined,\n          };\n          throw CopilotError.fromApiError(apiError, res.status);\n        }\n\n        return res;\n      });\n\n      const data = await response.json();\n\n      return {\n        success: true,\n        data: data as T,\n        metadata: {\n          requestId: response.headers.get('X-Request-ID') ?? '',\n          processingTimeMs: parseInt(\n            response.headers.get('X-Processing-Time') ?? '0',\n            10\n          ),\n          rateLimit: this.parseRateLimitHeaders(response.headers),\n        },\n      };\n    } catch (error) {\n      if (error instanceof CopilotError) {\n        throw error;\n      }\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new CopilotError('Request timeout', 'TIMEOUT', 408);\n      }\n\n      throw new CopilotError(\n        error instanceof Error ? error.message : 'Unknown error',\n        'NETWORK_ERROR'\n      );\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  /**\n   * Parse rate limit headers from response\n   */\n  private parseRateLimitHeaders(\n    headers: Headers\n  ): { limit: number; remaining: number; resetAt: Date } | undefined {\n    const limit = headers.get('X-RateLimit-Limit');\n    const remaining = headers.get('X-RateLimit-Remaining');\n    const reset = headers.get('X-RateLimit-Reset');\n\n    if (limit && remaining && reset) {\n      return {\n        limit: parseInt(limit, 10),\n        remaining: parseInt(remaining, 10),\n        resetAt: new Date(parseInt(reset, 10) * 1000),\n      };\n    }\n\n    return undefined;\n  }\n\n  /**\n   * GET request\n   */\n  async get<T>(\n    path: string,\n    query?: Record<string, string | number | boolean | undefined>,\n    options?: Omit<RequestOptions, 'method' | 'body' | 'query'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T>(path, { ...options, method: 'GET', query });\n  }\n\n  /**\n   * POST request\n   */\n  async post<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'POST', body });\n  }\n\n  /**\n   * PUT request\n   */\n  async put<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'PUT', body });\n  }\n\n  /**\n   * PATCH request\n   */\n  async patch<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'PATCH', body });\n  }\n\n  /**\n   * DELETE request\n   */\n  async delete<T>(\n    path: string,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T>(path, { ...options, method: 'DELETE' });\n  }\n\n  /**\n   * Stream request using Server-Sent Events\n   */\n  async stream(\n    path: string,\n    body: unknown,\n    handler: StreamHandler,\n    signal?: AbortSignal\n  ): Promise<void> {\n    const url = this.buildUrl(path);\n    const headers = this.buildHeaders({ Accept: 'text/event-stream' });\n\n    this.debug(`STREAM ${url}`);\n\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(body),\n        signal,\n      });\n\n      if (!response.ok) {\n        const errorBody = await response.json().catch(() => ({}));\n        throw CopilotError.fromApiError(\n          {\n            code: errorBody.code ?? 'STREAM_ERROR',\n            message: errorBody.message ?? response.statusText,\n          },\n          response.status\n        );\n      }\n\n      if (!response.body) {\n        throw new CopilotError('No response body', 'NO_BODY', 500);\n      }\n\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            handler.onComplete?.();\n            break;\n          }\n\n          const chunk = decoder.decode(value, { stream: true });\n          const lines = chunk.split('\\n');\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              const data = line.slice(6);\n              if (data === '[DONE]') {\n                handler.onComplete?.();\n                return;\n              }\n              handler.onChunk(data);\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    } catch (error) {\n      if (error instanceof CopilotError) {\n        handler.onError?.(error);\n        throw error;\n      }\n\n      const copilotError = new CopilotError(\n        error instanceof Error ? error.message : 'Stream error',\n        'STREAM_ERROR'\n      );\n      handler.onError?.(copilotError);\n      throw copilotError;\n    }\n  }\n\n  /**\n   * Paginated GET request\n   */\n  async paginate<T>(\n    path: string,\n    params?: PaginationParams & Record<string, unknown>\n  ): Promise<ApiResponse<PaginatedResponse<T>>> {\n    const { page = 1, pageSize = 20, cursor, ...rest } = params ?? {};\n\n    return this.get<PaginatedResponse<T>>(path, {\n      page,\n      page_size: pageSize,\n      cursor,\n      ...rest,\n    });\n  }\n\n  /**\n   * Iterate through all pages\n   */\n  async *paginateAll<T>(\n    path: string,\n    params?: Omit<PaginationParams, 'page' | 'cursor'> &\n      Record<string, unknown>\n  ): AsyncGenerator<T, void, unknown> {\n    let cursor: string | undefined;\n    let hasMore = true;\n\n    while (hasMore) {\n      const response = await this.paginate<T>(path, { ...params, cursor });\n\n      if (!response.success || !response.data) {\n        throw new CopilotError('Pagination failed', 'PAGINATION_ERROR');\n      }\n\n      for (const item of response.data.items) {\n        yield item;\n      }\n\n      hasMore = response.data.hasMore;\n      cursor = response.data.nextCursor;\n    }\n  }\n}\n\nexport { HttpClient as default };\n","/**\n * Context API client\n */\n\nimport { HttpClient, CopilotError } from '../client';\nimport type {\n  ContextItem,\n  ContextSearchParams,\n  ContextSearchResult,\n  DocumentInput,\n  IngestedDocument,\n  DocumentChunk,\n  PaginatedResponse,\n  PaginationParams,\n} from '../types';\n\n/**\n * Context search options\n */\ninterface SearchOptions extends ContextSearchParams {\n  /** Include vector scores in results */\n  includeScores?: boolean;\n  /** Use hybrid search (vector + keyword) */\n  hybrid?: boolean;\n  /** Rerank results */\n  rerank?: boolean;\n}\n\n/**\n * Document ingestion options\n */\ninterface IngestionOptions {\n  /** Chunking strategy */\n  chunkingStrategy?: 'fixed' | 'sentence' | 'paragraph' | 'recursive';\n  /** Target chunk size in tokens */\n  chunkSize?: number;\n  /** Overlap between chunks */\n  chunkOverlap?: number;\n  /** Generate embeddings */\n  generateEmbeddings?: boolean;\n  /** Wait for processing to complete */\n  waitForCompletion?: boolean;\n}\n\n/**\n * Context API client\n */\nexport class ContextClient {\n  constructor(private readonly client: HttpClient) {}\n\n  // ============================================================================\n  // Context Search\n  // ============================================================================\n\n  /**\n   * Search context\n   */\n  async search(options: SearchOptions): Promise<ContextSearchResult> {\n    const response = await this.client.post<ContextSearchResult>(\n      '/api/v1/context/search',\n      options\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Search failed', 'SEARCH_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Vector similarity search\n   */\n  async vectorSearch(\n    query: string,\n    options: { limit?: number; threshold?: number } = {}\n  ): Promise<ContextItem[]> {\n    const result = await this.search({\n      query,\n      ...options,\n      hybrid: false,\n    });\n\n    return result.items;\n  }\n\n  /**\n   * Hybrid search (vector + keyword)\n   */\n  async hybridSearch(\n    query: string,\n    options: {\n      limit?: number;\n      threshold?: number;\n      vectorWeight?: number;\n      keywordWeight?: number;\n    } = {}\n  ): Promise<ContextItem[]> {\n    const result = await this.search({\n      query,\n      limit: options.limit,\n      threshold: options.threshold,\n      hybrid: true,\n      filters: {\n        vectorWeight: options.vectorWeight ?? 0.7,\n        keywordWeight: options.keywordWeight ?? 0.3,\n      },\n    });\n\n    return result.items;\n  }\n\n  /**\n   * Search with reranking\n   */\n  async searchWithRerank(\n    query: string,\n    options: { limit?: number; initialLimit?: number } = {}\n  ): Promise<ContextItem[]> {\n    const result = await this.search({\n      query,\n      limit: options.limit ?? 10,\n      filters: {\n        initialLimit: options.initialLimit ?? 50,\n      },\n      rerank: true,\n    });\n\n    return result.items;\n  }\n\n  // ============================================================================\n  // Memory Management\n  // ============================================================================\n\n  /**\n   * Store a memory item\n   */\n  async storeMemory(\n    content: string,\n    options: {\n      type?: 'short_term' | 'long_term' | 'episodic';\n      importance?: number;\n      metadata?: Record<string, unknown>;\n    } = {}\n  ): Promise<ContextItem> {\n    const response = await this.client.post<ContextItem>('/api/v1/context/memory', {\n      content,\n      ...options,\n    });\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to store memory', 'STORE_MEMORY_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Get memory by ID\n   */\n  async getMemory(memoryId: string): Promise<ContextItem> {\n    const response = await this.client.get<ContextItem>(\n      `/api/v1/context/memory/${memoryId}`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Memory not found', 'NOT_FOUND', 404);\n    }\n\n    return response.data;\n  }\n\n  /**\n   * List memories\n   */\n  async listMemories(\n    params?: PaginationParams & { type?: string }\n  ): Promise<PaginatedResponse<ContextItem>> {\n    const response = await this.client.paginate<ContextItem>(\n      '/api/v1/context/memory',\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list memories', 'LIST_MEMORIES_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Delete a memory\n   */\n  async deleteMemory(memoryId: string): Promise<void> {\n    const response = await this.client.delete(`/api/v1/context/memory/${memoryId}`);\n\n    if (!response.success) {\n      throw new CopilotError('Failed to delete memory', 'DELETE_MEMORY_FAILED');\n    }\n  }\n\n  /**\n   * Consolidate memories\n   */\n  async consolidateMemories(): Promise<{ consolidated: number; remaining: number }> {\n    const response = await this.client.post<{\n      consolidated: number;\n      remaining: number;\n    }>('/api/v1/context/memory/consolidate');\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to consolidate memories',\n        'CONSOLIDATE_FAILED'\n      );\n    }\n\n    return response.data;\n  }\n\n  // ============================================================================\n  // Document Ingestion\n  // ============================================================================\n\n  /**\n   * Ingest a document\n   */\n  async ingestDocument(\n    input: DocumentInput,\n    options: IngestionOptions = {}\n  ): Promise<IngestedDocument> {\n    const { waitForCompletion = false, ...ingestionOptions } = options;\n\n    // Prepare form data for file upload\n    const formData = new FormData();\n\n    if (typeof input.content === 'string') {\n      formData.append('content', input.content);\n    } else {\n      // Convert Buffer to Uint8Array for Blob compatibility\n      const arrayBuffer = input.content instanceof ArrayBuffer\n        ? input.content\n        : new Uint8Array(input.content as Buffer);\n      formData.append(\n        'file',\n        new Blob([arrayBuffer]),\n        input.filename ?? 'document'\n      );\n    }\n\n    if (input.filename) {\n      formData.append('filename', input.filename);\n    }\n    if (input.contentType) {\n      formData.append('contentType', input.contentType);\n    }\n    if (input.metadata) {\n      formData.append('metadata', JSON.stringify(input.metadata));\n    }\n\n    Object.entries(ingestionOptions).forEach(([key, value]) => {\n      if (value !== undefined) {\n        formData.append(key, String(value));\n      }\n    });\n\n    // Note: In a real implementation, we'd need to handle FormData differently\n    const response = await this.client.post<IngestedDocument>(\n      '/api/v1/context/documents',\n      { ...input, ...ingestionOptions }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to ingest document', 'INGESTION_FAILED');\n    }\n\n    if (waitForCompletion) {\n      return this.waitForIngestion(response.data.id);\n    }\n\n    return this.parseDocument(response.data);\n  }\n\n  /**\n   * Ingest multiple documents\n   */\n  async ingestDocuments(\n    inputs: DocumentInput[],\n    options: IngestionOptions = {}\n  ): Promise<IngestedDocument[]> {\n    const results = await Promise.all(\n      inputs.map((input) => this.ingestDocument(input, options))\n    );\n\n    return results;\n  }\n\n  /**\n   * Get document by ID\n   */\n  async getDocument(documentId: string): Promise<IngestedDocument> {\n    const response = await this.client.get<IngestedDocument>(\n      `/api/v1/context/documents/${documentId}`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Document not found', 'NOT_FOUND', 404);\n    }\n\n    return this.parseDocument(response.data);\n  }\n\n  /**\n   * List documents\n   */\n  async listDocuments(\n    params?: PaginationParams & { status?: string }\n  ): Promise<PaginatedResponse<IngestedDocument>> {\n    const response = await this.client.paginate<IngestedDocument>(\n      '/api/v1/context/documents',\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list documents', 'LIST_DOCUMENTS_FAILED');\n    }\n\n    return {\n      ...response.data,\n      items: response.data.items.map((d) => this.parseDocument(d)),\n    };\n  }\n\n  /**\n   * Delete a document\n   */\n  async deleteDocument(documentId: string): Promise<void> {\n    const response = await this.client.delete(\n      `/api/v1/context/documents/${documentId}`\n    );\n\n    if (!response.success) {\n      throw new CopilotError('Failed to delete document', 'DELETE_DOCUMENT_FAILED');\n    }\n  }\n\n  /**\n   * Get document chunks\n   */\n  async getDocumentChunks(\n    documentId: string,\n    params?: PaginationParams\n  ): Promise<PaginatedResponse<DocumentChunk>> {\n    const response = await this.client.paginate<DocumentChunk>(\n      `/api/v1/context/documents/${documentId}/chunks`,\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to get document chunks', 'GET_CHUNKS_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Wait for document ingestion to complete\n   */\n  async waitForIngestion(\n    documentId: string,\n    options: { pollInterval?: number; timeout?: number } = {}\n  ): Promise<IngestedDocument> {\n    const { pollInterval = 1000, timeout = 300000 } = options;\n    const startTime = Date.now();\n\n    while (true) {\n      const document = await this.getDocument(documentId);\n\n      if (document.status === 'completed' || document.status === 'failed') {\n        return document;\n      }\n\n      if (Date.now() - startTime > timeout) {\n        throw new CopilotError('Document ingestion timeout', 'INGESTION_TIMEOUT');\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, pollInterval));\n    }\n  }\n\n  // ============================================================================\n  // Context Window Management\n  // ============================================================================\n\n  /**\n   * Build context window for a query\n   */\n  async buildContextWindow(\n    query: string,\n    options: {\n      maxTokens?: number;\n      includeMemory?: boolean;\n      includeDocuments?: boolean;\n      filters?: Record<string, unknown>;\n    } = {}\n  ): Promise<{ items: ContextItem[]; totalTokens: number }> {\n    const response = await this.client.post<{\n      items: ContextItem[];\n      totalTokens: number;\n    }>('/api/v1/context/window', {\n      query,\n      ...options,\n    });\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to build context window',\n        'BUILD_WINDOW_FAILED'\n      );\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Compress context to fit token budget\n   */\n  async compressContext(\n    items: ContextItem[],\n    maxTokens: number\n  ): Promise<{ items: ContextItem[]; totalTokens: number }> {\n    const response = await this.client.post<{\n      items: ContextItem[];\n      totalTokens: number;\n    }>('/api/v1/context/compress', {\n      items,\n      maxTokens,\n    });\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to compress context', 'COMPRESS_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Parse document response to ensure proper types\n   */\n  private parseDocument(data: IngestedDocument): IngestedDocument {\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      updatedAt: new Date(data.updatedAt),\n    };\n  }\n}\n\nexport default ContextClient;\n"]}