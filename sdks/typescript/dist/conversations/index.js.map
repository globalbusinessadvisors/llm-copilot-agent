{"version":3,"sources":["../../src/client.ts","../../src/conversations/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * HTTP Client for LLM-CoPilot SDK\n */\n\nimport type {\n  CopilotConfig,\n  ApiResponse,\n  ApiError,\n  PaginationParams,\n  PaginatedResponse,\n} from './types';\n\n/**\n * HTTP method types\n */\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n\n/**\n * Request options\n */\ninterface RequestOptions<T = unknown> {\n  method?: HttpMethod;\n  body?: T;\n  query?: Record<string, string | number | boolean | undefined>;\n  headers?: Record<string, string>;\n  signal?: AbortSignal;\n  timeout?: number;\n}\n\n/**\n * Stream response handler\n */\ninterface StreamHandler {\n  onChunk: (chunk: string) => void;\n  onError?: (error: Error) => void;\n  onComplete?: () => void;\n}\n\n/**\n * SDK Error class\n */\nexport class CopilotError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly status?: number,\n    public readonly details?: Record<string, unknown>,\n    public readonly requestId?: string\n  ) {\n    super(message);\n    this.name = 'CopilotError';\n  }\n\n  static fromApiError(error: ApiError, status?: number): CopilotError {\n    return new CopilotError(\n      error.message,\n      error.code,\n      status,\n      error.details,\n      error.requestId\n    );\n  }\n}\n\n/**\n * HTTP Client for making API requests\n */\nexport class HttpClient {\n  private readonly config: Required<\n    Pick<CopilotConfig, 'baseUrl' | 'apiKey' | 'timeout' | 'maxRetries'>\n  > &\n    Pick<CopilotConfig, 'tenantId' | 'headers' | 'debug'>;\n\n  constructor(config: CopilotConfig) {\n    this.config = {\n      baseUrl: config.baseUrl.replace(/\\/+$/, ''),\n      apiKey: config.apiKey,\n      timeout: config.timeout ?? 30000,\n      maxRetries: config.maxRetries ?? 3,\n      tenantId: config.tenantId,\n      headers: config.headers,\n      debug: config.debug,\n    };\n  }\n\n  /**\n   * Build full URL with query parameters\n   */\n  private buildUrl(\n    path: string,\n    query?: Record<string, string | number | boolean | undefined>\n  ): string {\n    const url = new URL(path, this.config.baseUrl);\n\n    if (query) {\n      Object.entries(query).forEach(([key, value]) => {\n        if (value !== undefined) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    return url.toString();\n  }\n\n  /**\n   * Build request headers\n   */\n  private buildHeaders(customHeaders?: Record<string, string>): Headers {\n    const headers = new Headers({\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${this.config.apiKey}`,\n      'User-Agent': '@llm-copilot/sdk',\n      ...this.config.headers,\n      ...customHeaders,\n    });\n\n    if (this.config.tenantId) {\n      headers.set('X-Tenant-ID', this.config.tenantId);\n    }\n\n    return headers;\n  }\n\n  /**\n   * Log debug information\n   */\n  private debug(message: string, data?: unknown): void {\n    if (this.config.debug) {\n      console.log(`[CopilotSDK] ${message}`, data ?? '');\n    }\n  }\n\n  /**\n   * Execute a request with retry logic\n   */\n  private async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    retries: number = this.config.maxRetries\n  ): Promise<T> {\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error as Error;\n\n        // Don't retry on client errors (4xx) except 429 (rate limit)\n        if (error instanceof CopilotError) {\n          if (\n            error.status &&\n            error.status >= 400 &&\n            error.status < 500 &&\n            error.status !== 429\n          ) {\n            throw error;\n          }\n        }\n\n        if (attempt < retries) {\n          const delay = Math.min(1000 * Math.pow(2, attempt), 10000);\n          this.debug(`Retry attempt ${attempt + 1} after ${delay}ms`);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Make an HTTP request\n   */\n  async request<T, B = unknown>(\n    path: string,\n    options: RequestOptions<B> = {}\n  ): Promise<ApiResponse<T>> {\n    const { method = 'GET', body, query, headers, signal, timeout } = options;\n\n    const url = this.buildUrl(path, query);\n    const requestHeaders = this.buildHeaders(headers);\n\n    this.debug(`${method} ${url}`);\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(\n      () => controller.abort(),\n      timeout ?? this.config.timeout\n    );\n\n    try {\n      const response = await this.executeWithRetry(async () => {\n        const res = await fetch(url, {\n          method,\n          headers: requestHeaders,\n          body: body ? JSON.stringify(body) : undefined,\n          signal: signal ?? controller.signal,\n        });\n\n        if (!res.ok) {\n          const errorBody = await res.json().catch(() => ({}));\n          const apiError: ApiError = {\n            code: errorBody.code ?? 'UNKNOWN_ERROR',\n            message: errorBody.message ?? res.statusText,\n            details: errorBody.details,\n            requestId: res.headers.get('X-Request-ID') ?? undefined,\n          };\n          throw CopilotError.fromApiError(apiError, res.status);\n        }\n\n        return res;\n      });\n\n      const data = await response.json();\n\n      return {\n        success: true,\n        data: data as T,\n        metadata: {\n          requestId: response.headers.get('X-Request-ID') ?? '',\n          processingTimeMs: parseInt(\n            response.headers.get('X-Processing-Time') ?? '0',\n            10\n          ),\n          rateLimit: this.parseRateLimitHeaders(response.headers),\n        },\n      };\n    } catch (error) {\n      if (error instanceof CopilotError) {\n        throw error;\n      }\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new CopilotError('Request timeout', 'TIMEOUT', 408);\n      }\n\n      throw new CopilotError(\n        error instanceof Error ? error.message : 'Unknown error',\n        'NETWORK_ERROR'\n      );\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  /**\n   * Parse rate limit headers from response\n   */\n  private parseRateLimitHeaders(\n    headers: Headers\n  ): { limit: number; remaining: number; resetAt: Date } | undefined {\n    const limit = headers.get('X-RateLimit-Limit');\n    const remaining = headers.get('X-RateLimit-Remaining');\n    const reset = headers.get('X-RateLimit-Reset');\n\n    if (limit && remaining && reset) {\n      return {\n        limit: parseInt(limit, 10),\n        remaining: parseInt(remaining, 10),\n        resetAt: new Date(parseInt(reset, 10) * 1000),\n      };\n    }\n\n    return undefined;\n  }\n\n  /**\n   * GET request\n   */\n  async get<T>(\n    path: string,\n    query?: Record<string, string | number | boolean | undefined>,\n    options?: Omit<RequestOptions, 'method' | 'body' | 'query'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T>(path, { ...options, method: 'GET', query });\n  }\n\n  /**\n   * POST request\n   */\n  async post<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'POST', body });\n  }\n\n  /**\n   * PUT request\n   */\n  async put<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'PUT', body });\n  }\n\n  /**\n   * PATCH request\n   */\n  async patch<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'PATCH', body });\n  }\n\n  /**\n   * DELETE request\n   */\n  async delete<T>(\n    path: string,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T>(path, { ...options, method: 'DELETE' });\n  }\n\n  /**\n   * Stream request using Server-Sent Events\n   */\n  async stream(\n    path: string,\n    body: unknown,\n    handler: StreamHandler,\n    signal?: AbortSignal\n  ): Promise<void> {\n    const url = this.buildUrl(path);\n    const headers = this.buildHeaders({ Accept: 'text/event-stream' });\n\n    this.debug(`STREAM ${url}`);\n\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(body),\n        signal,\n      });\n\n      if (!response.ok) {\n        const errorBody = await response.json().catch(() => ({}));\n        throw CopilotError.fromApiError(\n          {\n            code: errorBody.code ?? 'STREAM_ERROR',\n            message: errorBody.message ?? response.statusText,\n          },\n          response.status\n        );\n      }\n\n      if (!response.body) {\n        throw new CopilotError('No response body', 'NO_BODY', 500);\n      }\n\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            handler.onComplete?.();\n            break;\n          }\n\n          const chunk = decoder.decode(value, { stream: true });\n          const lines = chunk.split('\\n');\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              const data = line.slice(6);\n              if (data === '[DONE]') {\n                handler.onComplete?.();\n                return;\n              }\n              handler.onChunk(data);\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    } catch (error) {\n      if (error instanceof CopilotError) {\n        handler.onError?.(error);\n        throw error;\n      }\n\n      const copilotError = new CopilotError(\n        error instanceof Error ? error.message : 'Stream error',\n        'STREAM_ERROR'\n      );\n      handler.onError?.(copilotError);\n      throw copilotError;\n    }\n  }\n\n  /**\n   * Paginated GET request\n   */\n  async paginate<T>(\n    path: string,\n    params?: PaginationParams & Record<string, unknown>\n  ): Promise<ApiResponse<PaginatedResponse<T>>> {\n    const { page = 1, pageSize = 20, cursor, ...rest } = params ?? {};\n\n    return this.get<PaginatedResponse<T>>(path, {\n      page,\n      page_size: pageSize,\n      cursor,\n      ...rest,\n    });\n  }\n\n  /**\n   * Iterate through all pages\n   */\n  async *paginateAll<T>(\n    path: string,\n    params?: Omit<PaginationParams, 'page' | 'cursor'> &\n      Record<string, unknown>\n  ): AsyncGenerator<T, void, unknown> {\n    let cursor: string | undefined;\n    let hasMore = true;\n\n    while (hasMore) {\n      const response = await this.paginate<T>(path, { ...params, cursor });\n\n      if (!response.success || !response.data) {\n        throw new CopilotError('Pagination failed', 'PAGINATION_ERROR');\n      }\n\n      for (const item of response.data.items) {\n        yield item;\n      }\n\n      hasMore = response.data.hasMore;\n      cursor = response.data.nextCursor;\n    }\n  }\n}\n\nexport { HttpClient as default };\n","/**\n * Conversations API client\n */\n\nimport { HttpClient, CopilotError } from '../client';\nimport type {\n  Conversation,\n  CreateConversationInput,\n  Message,\n  MessageInput,\n  SendMessageOptions,\n  StreamOptions,\n  PaginatedResponse,\n  PaginationParams,\n  ContentDelta,\n  StreamEvent,\n} from '../types';\n\n/**\n * Conversations API client\n */\nexport class ConversationsClient {\n  constructor(private readonly client: HttpClient) {}\n\n  /**\n   * Create a new conversation\n   */\n  async create(input: CreateConversationInput = {}): Promise<Conversation> {\n    const response = await this.client.post<Conversation>(\n      '/api/v1/conversations',\n      input\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to create conversation', 'CREATE_FAILED');\n    }\n\n    return this.parseConversation(response.data);\n  }\n\n  /**\n   * Get a conversation by ID\n   */\n  async get(conversationId: string): Promise<Conversation> {\n    const response = await this.client.get<Conversation>(\n      `/api/v1/conversations/${conversationId}`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Conversation not found', 'NOT_FOUND', 404);\n    }\n\n    return this.parseConversation(response.data);\n  }\n\n  /**\n   * List conversations\n   */\n  async list(\n    params?: PaginationParams & { status?: string }\n  ): Promise<PaginatedResponse<Conversation>> {\n    const response = await this.client.paginate<Conversation>(\n      '/api/v1/conversations',\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list conversations', 'LIST_FAILED');\n    }\n\n    return {\n      ...response.data,\n      items: response.data.items.map((c) => this.parseConversation(c)),\n    };\n  }\n\n  /**\n   * Update a conversation\n   */\n  async update(\n    conversationId: string,\n    updates: { title?: string; metadata?: Record<string, unknown> }\n  ): Promise<Conversation> {\n    const response = await this.client.patch<Conversation>(\n      `/api/v1/conversations/${conversationId}`,\n      updates\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to update conversation', 'UPDATE_FAILED');\n    }\n\n    return this.parseConversation(response.data);\n  }\n\n  /**\n   * Delete a conversation\n   */\n  async delete(conversationId: string): Promise<void> {\n    const response = await this.client.delete(\n      `/api/v1/conversations/${conversationId}`\n    );\n\n    if (!response.success) {\n      throw new CopilotError('Failed to delete conversation', 'DELETE_FAILED');\n    }\n  }\n\n  /**\n   * Archive a conversation\n   */\n  async archive(conversationId: string): Promise<Conversation> {\n    const response = await this.client.post<Conversation>(\n      `/api/v1/conversations/${conversationId}/archive`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to archive conversation',\n        'ARCHIVE_FAILED'\n      );\n    }\n\n    return this.parseConversation(response.data);\n  }\n\n  /**\n   * Send a message to a conversation\n   */\n  async sendMessage(\n    conversationId: string,\n    content: string,\n    options: SendMessageOptions = {}\n  ): Promise<Message> {\n    const { stream, ...rest } = options;\n\n    if (stream) {\n      throw new CopilotError(\n        'Use streamMessage() for streaming responses',\n        'USE_STREAM_METHOD'\n      );\n    }\n\n    const response = await this.client.post<Message>(\n      `/api/v1/conversations/${conversationId}/messages`,\n      { content, ...rest }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to send message', 'SEND_FAILED');\n    }\n\n    return this.parseMessage(response.data);\n  }\n\n  /**\n   * Stream a message response\n   */\n  async streamMessage(\n    conversationId: string,\n    content: string,\n    options: StreamOptions & Omit<SendMessageOptions, 'stream'> = {}\n  ): Promise<Message> {\n    const { onChunk, onEvent, onError, onComplete, signal, ...rest } = options;\n\n    let fullContent = '';\n    let messageId = '';\n\n    return new Promise<Message>((resolve, reject) => {\n      this.client\n        .stream(\n          `/api/v1/conversations/${conversationId}/messages/stream`,\n          { content, ...rest },\n          {\n            onChunk: (data) => {\n              try {\n                const event = JSON.parse(data) as StreamEvent;\n\n                switch (event.type) {\n                  case 'message_start':\n                    messageId = (event.data as { id: string }).id;\n                    break;\n\n                  case 'content_delta':\n                    const delta = event.data as ContentDelta;\n                    fullContent += delta.text;\n                    onChunk?.(delta.text);\n                    break;\n\n                  case 'message_stop':\n                    break;\n                }\n\n                onEvent?.(event);\n              } catch (error) {\n                // Not JSON, treat as raw text\n                fullContent += data;\n                onChunk?.(data);\n              }\n            },\n            onError: (error) => {\n              onError?.(error);\n              reject(error);\n            },\n            onComplete: () => {\n              const message: Message = {\n                id: messageId || 'streamed',\n                role: 'assistant',\n                content: fullContent,\n                createdAt: new Date(),\n              };\n              onComplete?.(message);\n              resolve(message);\n            },\n          },\n          signal\n        )\n        .catch(reject);\n    });\n  }\n\n  /**\n   * Get messages from a conversation\n   */\n  async getMessages(\n    conversationId: string,\n    params?: PaginationParams\n  ): Promise<PaginatedResponse<Message>> {\n    const response = await this.client.paginate<Message>(\n      `/api/v1/conversations/${conversationId}/messages`,\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to get messages', 'GET_MESSAGES_FAILED');\n    }\n\n    return {\n      ...response.data,\n      items: response.data.items.map((m) => this.parseMessage(m)),\n    };\n  }\n\n  /**\n   * Add a message without generating a response\n   */\n  async addMessage(\n    conversationId: string,\n    message: MessageInput\n  ): Promise<Message> {\n    const response = await this.client.post<Message>(\n      `/api/v1/conversations/${conversationId}/messages/add`,\n      message\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to add message', 'ADD_MESSAGE_FAILED');\n    }\n\n    return this.parseMessage(response.data);\n  }\n\n  /**\n   * Fork a conversation from a specific message\n   */\n  async fork(conversationId: string, messageId: string): Promise<Conversation> {\n    const response = await this.client.post<Conversation>(\n      `/api/v1/conversations/${conversationId}/fork`,\n      { messageId }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to fork conversation', 'FORK_FAILED');\n    }\n\n    return this.parseConversation(response.data);\n  }\n\n  /**\n   * Get conversation summary\n   */\n  async getSummary(conversationId: string): Promise<string> {\n    const response = await this.client.get<{ summary: string }>(\n      `/api/v1/conversations/${conversationId}/summary`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to get summary', 'SUMMARY_FAILED');\n    }\n\n    return response.data.summary;\n  }\n\n  /**\n   * Export conversation\n   */\n  async export(\n    conversationId: string,\n    format: 'json' | 'markdown' = 'json'\n  ): Promise<string> {\n    const response = await this.client.get<{ content: string }>(\n      `/api/v1/conversations/${conversationId}/export`,\n      { format }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to export conversation', 'EXPORT_FAILED');\n    }\n\n    return response.data.content;\n  }\n\n  /**\n   * Parse conversation response to ensure proper types\n   */\n  private parseConversation(data: Conversation): Conversation {\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      updatedAt: new Date(data.updatedAt),\n      messages: data.messages?.map((m) => this.parseMessage(m)) ?? [],\n    };\n  }\n\n  /**\n   * Parse message response to ensure proper types\n   */\n  private parseMessage(data: Message): Message {\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n    };\n  }\n}\n\nexport default ConversationsClient;\n"]}