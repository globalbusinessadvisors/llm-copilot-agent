{"version":3,"sources":["../src/client.ts","../src/conversations/index.ts","../src/workflows/index.ts","../src/context/index.ts","../src/types.ts","../src/index.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * HTTP Client for LLM-CoPilot SDK\n */\n\nimport type {\n  CopilotConfig,\n  ApiResponse,\n  ApiError,\n  PaginationParams,\n  PaginatedResponse,\n} from './types';\n\n/**\n * HTTP method types\n */\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n\n/**\n * Request options\n */\ninterface RequestOptions<T = unknown> {\n  method?: HttpMethod;\n  body?: T;\n  query?: Record<string, string | number | boolean | undefined>;\n  headers?: Record<string, string>;\n  signal?: AbortSignal;\n  timeout?: number;\n}\n\n/**\n * Stream response handler\n */\ninterface StreamHandler {\n  onChunk: (chunk: string) => void;\n  onError?: (error: Error) => void;\n  onComplete?: () => void;\n}\n\n/**\n * SDK Error class\n */\nexport class CopilotError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly status?: number,\n    public readonly details?: Record<string, unknown>,\n    public readonly requestId?: string\n  ) {\n    super(message);\n    this.name = 'CopilotError';\n  }\n\n  static fromApiError(error: ApiError, status?: number): CopilotError {\n    return new CopilotError(\n      error.message,\n      error.code,\n      status,\n      error.details,\n      error.requestId\n    );\n  }\n}\n\n/**\n * HTTP Client for making API requests\n */\nexport class HttpClient {\n  private readonly config: Required<\n    Pick<CopilotConfig, 'baseUrl' | 'apiKey' | 'timeout' | 'maxRetries'>\n  > &\n    Pick<CopilotConfig, 'tenantId' | 'headers' | 'debug'>;\n\n  constructor(config: CopilotConfig) {\n    this.config = {\n      baseUrl: config.baseUrl.replace(/\\/+$/, ''),\n      apiKey: config.apiKey,\n      timeout: config.timeout ?? 30000,\n      maxRetries: config.maxRetries ?? 3,\n      tenantId: config.tenantId,\n      headers: config.headers,\n      debug: config.debug,\n    };\n  }\n\n  /**\n   * Build full URL with query parameters\n   */\n  private buildUrl(\n    path: string,\n    query?: Record<string, string | number | boolean | undefined>\n  ): string {\n    const url = new URL(path, this.config.baseUrl);\n\n    if (query) {\n      Object.entries(query).forEach(([key, value]) => {\n        if (value !== undefined) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    return url.toString();\n  }\n\n  /**\n   * Build request headers\n   */\n  private buildHeaders(customHeaders?: Record<string, string>): Headers {\n    const headers = new Headers({\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${this.config.apiKey}`,\n      'User-Agent': '@llm-copilot/sdk',\n      ...this.config.headers,\n      ...customHeaders,\n    });\n\n    if (this.config.tenantId) {\n      headers.set('X-Tenant-ID', this.config.tenantId);\n    }\n\n    return headers;\n  }\n\n  /**\n   * Log debug information\n   */\n  private debug(message: string, data?: unknown): void {\n    if (this.config.debug) {\n      console.log(`[CopilotSDK] ${message}`, data ?? '');\n    }\n  }\n\n  /**\n   * Execute a request with retry logic\n   */\n  private async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    retries: number = this.config.maxRetries\n  ): Promise<T> {\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error as Error;\n\n        // Don't retry on client errors (4xx) except 429 (rate limit)\n        if (error instanceof CopilotError) {\n          if (\n            error.status &&\n            error.status >= 400 &&\n            error.status < 500 &&\n            error.status !== 429\n          ) {\n            throw error;\n          }\n        }\n\n        if (attempt < retries) {\n          const delay = Math.min(1000 * Math.pow(2, attempt), 10000);\n          this.debug(`Retry attempt ${attempt + 1} after ${delay}ms`);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Make an HTTP request\n   */\n  async request<T, B = unknown>(\n    path: string,\n    options: RequestOptions<B> = {}\n  ): Promise<ApiResponse<T>> {\n    const { method = 'GET', body, query, headers, signal, timeout } = options;\n\n    const url = this.buildUrl(path, query);\n    const requestHeaders = this.buildHeaders(headers);\n\n    this.debug(`${method} ${url}`);\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(\n      () => controller.abort(),\n      timeout ?? this.config.timeout\n    );\n\n    try {\n      const response = await this.executeWithRetry(async () => {\n        const res = await fetch(url, {\n          method,\n          headers: requestHeaders,\n          body: body ? JSON.stringify(body) : undefined,\n          signal: signal ?? controller.signal,\n        });\n\n        if (!res.ok) {\n          const errorBody = await res.json().catch(() => ({}));\n          const apiError: ApiError = {\n            code: errorBody.code ?? 'UNKNOWN_ERROR',\n            message: errorBody.message ?? res.statusText,\n            details: errorBody.details,\n            requestId: res.headers.get('X-Request-ID') ?? undefined,\n          };\n          throw CopilotError.fromApiError(apiError, res.status);\n        }\n\n        return res;\n      });\n\n      const data = await response.json();\n\n      return {\n        success: true,\n        data: data as T,\n        metadata: {\n          requestId: response.headers.get('X-Request-ID') ?? '',\n          processingTimeMs: parseInt(\n            response.headers.get('X-Processing-Time') ?? '0',\n            10\n          ),\n          rateLimit: this.parseRateLimitHeaders(response.headers),\n        },\n      };\n    } catch (error) {\n      if (error instanceof CopilotError) {\n        throw error;\n      }\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new CopilotError('Request timeout', 'TIMEOUT', 408);\n      }\n\n      throw new CopilotError(\n        error instanceof Error ? error.message : 'Unknown error',\n        'NETWORK_ERROR'\n      );\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  /**\n   * Parse rate limit headers from response\n   */\n  private parseRateLimitHeaders(\n    headers: Headers\n  ): { limit: number; remaining: number; resetAt: Date } | undefined {\n    const limit = headers.get('X-RateLimit-Limit');\n    const remaining = headers.get('X-RateLimit-Remaining');\n    const reset = headers.get('X-RateLimit-Reset');\n\n    if (limit && remaining && reset) {\n      return {\n        limit: parseInt(limit, 10),\n        remaining: parseInt(remaining, 10),\n        resetAt: new Date(parseInt(reset, 10) * 1000),\n      };\n    }\n\n    return undefined;\n  }\n\n  /**\n   * GET request\n   */\n  async get<T>(\n    path: string,\n    query?: Record<string, string | number | boolean | undefined>,\n    options?: Omit<RequestOptions, 'method' | 'body' | 'query'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T>(path, { ...options, method: 'GET', query });\n  }\n\n  /**\n   * POST request\n   */\n  async post<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'POST', body });\n  }\n\n  /**\n   * PUT request\n   */\n  async put<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'PUT', body });\n  }\n\n  /**\n   * PATCH request\n   */\n  async patch<T, B = unknown>(\n    path: string,\n    body?: B,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T, B>(path, { ...options, method: 'PATCH', body });\n  }\n\n  /**\n   * DELETE request\n   */\n  async delete<T>(\n    path: string,\n    options?: Omit<RequestOptions, 'method' | 'body'>\n  ): Promise<ApiResponse<T>> {\n    return this.request<T>(path, { ...options, method: 'DELETE' });\n  }\n\n  /**\n   * Stream request using Server-Sent Events\n   */\n  async stream(\n    path: string,\n    body: unknown,\n    handler: StreamHandler,\n    signal?: AbortSignal\n  ): Promise<void> {\n    const url = this.buildUrl(path);\n    const headers = this.buildHeaders({ Accept: 'text/event-stream' });\n\n    this.debug(`STREAM ${url}`);\n\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(body),\n        signal,\n      });\n\n      if (!response.ok) {\n        const errorBody = await response.json().catch(() => ({}));\n        throw CopilotError.fromApiError(\n          {\n            code: errorBody.code ?? 'STREAM_ERROR',\n            message: errorBody.message ?? response.statusText,\n          },\n          response.status\n        );\n      }\n\n      if (!response.body) {\n        throw new CopilotError('No response body', 'NO_BODY', 500);\n      }\n\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            handler.onComplete?.();\n            break;\n          }\n\n          const chunk = decoder.decode(value, { stream: true });\n          const lines = chunk.split('\\n');\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              const data = line.slice(6);\n              if (data === '[DONE]') {\n                handler.onComplete?.();\n                return;\n              }\n              handler.onChunk(data);\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    } catch (error) {\n      if (error instanceof CopilotError) {\n        handler.onError?.(error);\n        throw error;\n      }\n\n      const copilotError = new CopilotError(\n        error instanceof Error ? error.message : 'Stream error',\n        'STREAM_ERROR'\n      );\n      handler.onError?.(copilotError);\n      throw copilotError;\n    }\n  }\n\n  /**\n   * Paginated GET request\n   */\n  async paginate<T>(\n    path: string,\n    params?: PaginationParams & Record<string, unknown>\n  ): Promise<ApiResponse<PaginatedResponse<T>>> {\n    const { page = 1, pageSize = 20, cursor, ...rest } = params ?? {};\n\n    return this.get<PaginatedResponse<T>>(path, {\n      page,\n      page_size: pageSize,\n      cursor,\n      ...rest,\n    });\n  }\n\n  /**\n   * Iterate through all pages\n   */\n  async *paginateAll<T>(\n    path: string,\n    params?: Omit<PaginationParams, 'page' | 'cursor'> &\n      Record<string, unknown>\n  ): AsyncGenerator<T, void, unknown> {\n    let cursor: string | undefined;\n    let hasMore = true;\n\n    while (hasMore) {\n      const response = await this.paginate<T>(path, { ...params, cursor });\n\n      if (!response.success || !response.data) {\n        throw new CopilotError('Pagination failed', 'PAGINATION_ERROR');\n      }\n\n      for (const item of response.data.items) {\n        yield item;\n      }\n\n      hasMore = response.data.hasMore;\n      cursor = response.data.nextCursor;\n    }\n  }\n}\n\nexport { HttpClient as default };\n","/**\n * Conversations API client\n */\n\nimport { HttpClient, CopilotError } from '../client';\nimport type {\n  Conversation,\n  CreateConversationInput,\n  Message,\n  MessageInput,\n  SendMessageOptions,\n  StreamOptions,\n  PaginatedResponse,\n  PaginationParams,\n  ContentDelta,\n  StreamEvent,\n} from '../types';\n\n/**\n * Conversations API client\n */\nexport class ConversationsClient {\n  constructor(private readonly client: HttpClient) {}\n\n  /**\n   * Create a new conversation\n   */\n  async create(input: CreateConversationInput = {}): Promise<Conversation> {\n    const response = await this.client.post<Conversation>(\n      '/api/v1/conversations',\n      input\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to create conversation', 'CREATE_FAILED');\n    }\n\n    return this.parseConversation(response.data);\n  }\n\n  /**\n   * Get a conversation by ID\n   */\n  async get(conversationId: string): Promise<Conversation> {\n    const response = await this.client.get<Conversation>(\n      `/api/v1/conversations/${conversationId}`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Conversation not found', 'NOT_FOUND', 404);\n    }\n\n    return this.parseConversation(response.data);\n  }\n\n  /**\n   * List conversations\n   */\n  async list(\n    params?: PaginationParams & { status?: string }\n  ): Promise<PaginatedResponse<Conversation>> {\n    const response = await this.client.paginate<Conversation>(\n      '/api/v1/conversations',\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list conversations', 'LIST_FAILED');\n    }\n\n    return {\n      ...response.data,\n      items: response.data.items.map((c) => this.parseConversation(c)),\n    };\n  }\n\n  /**\n   * Update a conversation\n   */\n  async update(\n    conversationId: string,\n    updates: { title?: string; metadata?: Record<string, unknown> }\n  ): Promise<Conversation> {\n    const response = await this.client.patch<Conversation>(\n      `/api/v1/conversations/${conversationId}`,\n      updates\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to update conversation', 'UPDATE_FAILED');\n    }\n\n    return this.parseConversation(response.data);\n  }\n\n  /**\n   * Delete a conversation\n   */\n  async delete(conversationId: string): Promise<void> {\n    const response = await this.client.delete(\n      `/api/v1/conversations/${conversationId}`\n    );\n\n    if (!response.success) {\n      throw new CopilotError('Failed to delete conversation', 'DELETE_FAILED');\n    }\n  }\n\n  /**\n   * Archive a conversation\n   */\n  async archive(conversationId: string): Promise<Conversation> {\n    const response = await this.client.post<Conversation>(\n      `/api/v1/conversations/${conversationId}/archive`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to archive conversation',\n        'ARCHIVE_FAILED'\n      );\n    }\n\n    return this.parseConversation(response.data);\n  }\n\n  /**\n   * Send a message to a conversation\n   */\n  async sendMessage(\n    conversationId: string,\n    content: string,\n    options: SendMessageOptions = {}\n  ): Promise<Message> {\n    const { stream, ...rest } = options;\n\n    if (stream) {\n      throw new CopilotError(\n        'Use streamMessage() for streaming responses',\n        'USE_STREAM_METHOD'\n      );\n    }\n\n    const response = await this.client.post<Message>(\n      `/api/v1/conversations/${conversationId}/messages`,\n      { content, ...rest }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to send message', 'SEND_FAILED');\n    }\n\n    return this.parseMessage(response.data);\n  }\n\n  /**\n   * Stream a message response\n   */\n  async streamMessage(\n    conversationId: string,\n    content: string,\n    options: StreamOptions & Omit<SendMessageOptions, 'stream'> = {}\n  ): Promise<Message> {\n    const { onChunk, onEvent, onError, onComplete, signal, ...rest } = options;\n\n    let fullContent = '';\n    let messageId = '';\n\n    return new Promise<Message>((resolve, reject) => {\n      this.client\n        .stream(\n          `/api/v1/conversations/${conversationId}/messages/stream`,\n          { content, ...rest },\n          {\n            onChunk: (data) => {\n              try {\n                const event = JSON.parse(data) as StreamEvent;\n\n                switch (event.type) {\n                  case 'message_start':\n                    messageId = (event.data as { id: string }).id;\n                    break;\n\n                  case 'content_delta':\n                    const delta = event.data as ContentDelta;\n                    fullContent += delta.text;\n                    onChunk?.(delta.text);\n                    break;\n\n                  case 'message_stop':\n                    break;\n                }\n\n                onEvent?.(event);\n              } catch (error) {\n                // Not JSON, treat as raw text\n                fullContent += data;\n                onChunk?.(data);\n              }\n            },\n            onError: (error) => {\n              onError?.(error);\n              reject(error);\n            },\n            onComplete: () => {\n              const message: Message = {\n                id: messageId || 'streamed',\n                role: 'assistant',\n                content: fullContent,\n                createdAt: new Date(),\n              };\n              onComplete?.(message);\n              resolve(message);\n            },\n          },\n          signal\n        )\n        .catch(reject);\n    });\n  }\n\n  /**\n   * Get messages from a conversation\n   */\n  async getMessages(\n    conversationId: string,\n    params?: PaginationParams\n  ): Promise<PaginatedResponse<Message>> {\n    const response = await this.client.paginate<Message>(\n      `/api/v1/conversations/${conversationId}/messages`,\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to get messages', 'GET_MESSAGES_FAILED');\n    }\n\n    return {\n      ...response.data,\n      items: response.data.items.map((m) => this.parseMessage(m)),\n    };\n  }\n\n  /**\n   * Add a message without generating a response\n   */\n  async addMessage(\n    conversationId: string,\n    message: MessageInput\n  ): Promise<Message> {\n    const response = await this.client.post<Message>(\n      `/api/v1/conversations/${conversationId}/messages/add`,\n      message\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to add message', 'ADD_MESSAGE_FAILED');\n    }\n\n    return this.parseMessage(response.data);\n  }\n\n  /**\n   * Fork a conversation from a specific message\n   */\n  async fork(conversationId: string, messageId: string): Promise<Conversation> {\n    const response = await this.client.post<Conversation>(\n      `/api/v1/conversations/${conversationId}/fork`,\n      { messageId }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to fork conversation', 'FORK_FAILED');\n    }\n\n    return this.parseConversation(response.data);\n  }\n\n  /**\n   * Get conversation summary\n   */\n  async getSummary(conversationId: string): Promise<string> {\n    const response = await this.client.get<{ summary: string }>(\n      `/api/v1/conversations/${conversationId}/summary`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to get summary', 'SUMMARY_FAILED');\n    }\n\n    return response.data.summary;\n  }\n\n  /**\n   * Export conversation\n   */\n  async export(\n    conversationId: string,\n    format: 'json' | 'markdown' = 'json'\n  ): Promise<string> {\n    const response = await this.client.get<{ content: string }>(\n      `/api/v1/conversations/${conversationId}/export`,\n      { format }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to export conversation', 'EXPORT_FAILED');\n    }\n\n    return response.data.content;\n  }\n\n  /**\n   * Parse conversation response to ensure proper types\n   */\n  private parseConversation(data: Conversation): Conversation {\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      updatedAt: new Date(data.updatedAt),\n      messages: data.messages?.map((m) => this.parseMessage(m)) ?? [],\n    };\n  }\n\n  /**\n   * Parse message response to ensure proper types\n   */\n  private parseMessage(data: Message): Message {\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n    };\n  }\n}\n\nexport default ConversationsClient;\n","/**\n * Workflows API client\n */\n\nimport { HttpClient, CopilotError } from '../client';\nimport type {\n  WorkflowDefinition,\n  WorkflowExecution,\n  CreateWorkflowInput,\n  ExecuteWorkflowInput,\n  WorkflowStatus,\n  StepResult,\n  PaginatedResponse,\n  PaginationParams,\n  StreamOptions,\n  StreamEvent,\n} from '../types';\n\n/**\n * Workflow execution event\n */\ninterface WorkflowEvent {\n  type: 'step_started' | 'step_completed' | 'step_failed' | 'workflow_completed';\n  stepId?: string;\n  result?: StepResult;\n  error?: string;\n}\n\n/**\n * Workflows API client\n */\nexport class WorkflowsClient {\n  constructor(private readonly client: HttpClient) {}\n\n  // ============================================================================\n  // Workflow Definitions\n  // ============================================================================\n\n  /**\n   * Create a new workflow\n   */\n  async create(input: CreateWorkflowInput): Promise<WorkflowDefinition> {\n    const response = await this.client.post<WorkflowDefinition>(\n      '/api/v1/workflows',\n      input\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to create workflow', 'CREATE_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Get a workflow by ID\n   */\n  async get(workflowId: string): Promise<WorkflowDefinition> {\n    const response = await this.client.get<WorkflowDefinition>(\n      `/api/v1/workflows/${workflowId}`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Workflow not found', 'NOT_FOUND', 404);\n    }\n\n    return response.data;\n  }\n\n  /**\n   * List workflows\n   */\n  async list(\n    params?: PaginationParams\n  ): Promise<PaginatedResponse<WorkflowDefinition>> {\n    const response = await this.client.paginate<WorkflowDefinition>(\n      '/api/v1/workflows',\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list workflows', 'LIST_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Update a workflow\n   */\n  async update(\n    workflowId: string,\n    updates: Partial<CreateWorkflowInput>\n  ): Promise<WorkflowDefinition> {\n    const response = await this.client.patch<WorkflowDefinition>(\n      `/api/v1/workflows/${workflowId}`,\n      updates\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to update workflow', 'UPDATE_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Delete a workflow\n   */\n  async delete(workflowId: string): Promise<void> {\n    const response = await this.client.delete(\n      `/api/v1/workflows/${workflowId}`\n    );\n\n    if (!response.success) {\n      throw new CopilotError('Failed to delete workflow', 'DELETE_FAILED');\n    }\n  }\n\n  /**\n   * Create a new version of a workflow\n   */\n  async createVersion(\n    workflowId: string,\n    versionType: 'major' | 'minor' | 'patch' = 'minor'\n  ): Promise<WorkflowDefinition> {\n    const response = await this.client.post<WorkflowDefinition>(\n      `/api/v1/workflows/${workflowId}/versions`,\n      { versionType }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to create workflow version',\n        'VERSION_FAILED'\n      );\n    }\n\n    return response.data;\n  }\n\n  /**\n   * List workflow versions\n   */\n  async listVersions(\n    workflowId: string\n  ): Promise<PaginatedResponse<WorkflowDefinition>> {\n    const response = await this.client.paginate<WorkflowDefinition>(\n      `/api/v1/workflows/${workflowId}/versions`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to list workflow versions',\n        'LIST_VERSIONS_FAILED'\n      );\n    }\n\n    return response.data;\n  }\n\n  // ============================================================================\n  // Workflow Execution\n  // ============================================================================\n\n  /**\n   * Execute a workflow\n   */\n  async execute(input: ExecuteWorkflowInput): Promise<WorkflowExecution> {\n    const { workflowId, ...rest } = input;\n\n    const response = await this.client.post<WorkflowExecution>(\n      `/api/v1/workflows/${workflowId}/execute`,\n      rest\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to execute workflow', 'EXECUTE_FAILED');\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * Execute a workflow and stream progress\n   */\n  async executeWithStream(\n    input: ExecuteWorkflowInput,\n    options: StreamOptions & {\n      onStep?: (stepId: string, result: StepResult) => void;\n    } = {}\n  ): Promise<WorkflowExecution> {\n    const { workflowId, ...rest } = input;\n    const { onChunk, onEvent, onError, onComplete, onStep, signal } = options;\n\n    let execution: Partial<WorkflowExecution> = {};\n\n    return new Promise<WorkflowExecution>((resolve, reject) => {\n      this.client\n        .stream(\n          `/api/v1/workflows/${workflowId}/execute/stream`,\n          { ...rest, stream: true },\n          {\n            onChunk: (data) => {\n              try {\n                const event = JSON.parse(data) as StreamEvent<WorkflowEvent>;\n\n                if (event.type === 'message_start') {\n                  execution = event.data as Partial<WorkflowExecution>;\n                }\n\n                const workflowEvent = event.data as WorkflowEvent;\n\n                switch (workflowEvent.type) {\n                  case 'step_started':\n                    onChunk?.(`Step started: ${workflowEvent.stepId}`);\n                    break;\n\n                  case 'step_completed':\n                    if (workflowEvent.stepId && workflowEvent.result) {\n                      onStep?.(workflowEvent.stepId, workflowEvent.result);\n                    }\n                    onChunk?.(`Step completed: ${workflowEvent.stepId}`);\n                    break;\n\n                  case 'step_failed':\n                    onChunk?.(\n                      `Step failed: ${workflowEvent.stepId} - ${workflowEvent.error}`\n                    );\n                    break;\n\n                  case 'workflow_completed':\n                    break;\n                }\n\n                onEvent?.(event);\n              } catch {\n                onChunk?.(data);\n              }\n            },\n            onError: (error) => {\n              onError?.(error);\n              reject(error);\n            },\n            onComplete: () => {\n              const finalExecution = this.parseExecution(\n                execution as WorkflowExecution\n              );\n              onComplete?.(finalExecution as never);\n              resolve(finalExecution);\n            },\n          },\n          signal\n        )\n        .catch(reject);\n    });\n  }\n\n  /**\n   * Get execution status\n   */\n  async getExecution(executionId: string): Promise<WorkflowExecution> {\n    const response = await this.client.get<WorkflowExecution>(\n      `/api/v1/executions/${executionId}`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Execution not found', 'NOT_FOUND', 404);\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * List executions for a workflow\n   */\n  async listExecutions(\n    workflowId: string,\n    params?: PaginationParams & { status?: WorkflowStatus }\n  ): Promise<PaginatedResponse<WorkflowExecution>> {\n    const response = await this.client.paginate<WorkflowExecution>(\n      `/api/v1/workflows/${workflowId}/executions`,\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list executions', 'LIST_FAILED');\n    }\n\n    return {\n      ...response.data,\n      items: response.data.items.map((e) => this.parseExecution(e)),\n    };\n  }\n\n  /**\n   * Cancel a running execution\n   */\n  async cancelExecution(executionId: string): Promise<WorkflowExecution> {\n    const response = await this.client.post<WorkflowExecution>(\n      `/api/v1/executions/${executionId}/cancel`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to cancel execution', 'CANCEL_FAILED');\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * Retry a failed execution\n   */\n  async retryExecution(\n    executionId: string,\n    fromStep?: string\n  ): Promise<WorkflowExecution> {\n    const response = await this.client.post<WorkflowExecution>(\n      `/api/v1/executions/${executionId}/retry`,\n      { fromStep }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to retry execution', 'RETRY_FAILED');\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * Pause a running execution\n   */\n  async pauseExecution(executionId: string): Promise<WorkflowExecution> {\n    const response = await this.client.post<WorkflowExecution>(\n      `/api/v1/executions/${executionId}/pause`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to pause execution', 'PAUSE_FAILED');\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * Resume a paused execution\n   */\n  async resumeExecution(executionId: string): Promise<WorkflowExecution> {\n    const response = await this.client.post<WorkflowExecution>(\n      `/api/v1/executions/${executionId}/resume`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to resume execution', 'RESUME_FAILED');\n    }\n\n    return this.parseExecution(response.data);\n  }\n\n  /**\n   * Poll execution until completion\n   */\n  async waitForCompletion(\n    executionId: string,\n    options: {\n      pollInterval?: number;\n      timeout?: number;\n      onProgress?: (execution: WorkflowExecution) => void;\n    } = {}\n  ): Promise<WorkflowExecution> {\n    const { pollInterval = 1000, timeout = 300000, onProgress } = options;\n    const startTime = Date.now();\n\n    while (true) {\n      const execution = await this.getExecution(executionId);\n\n      onProgress?.(execution);\n\n      if (\n        execution.status === 'completed' ||\n        execution.status === 'failed' ||\n        execution.status === 'cancelled'\n      ) {\n        return execution;\n      }\n\n      if (Date.now() - startTime > timeout) {\n        throw new CopilotError(\n          'Workflow execution timeout',\n          'EXECUTION_TIMEOUT'\n        );\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, pollInterval));\n    }\n  }\n\n  // ============================================================================\n  // Templates\n  // ============================================================================\n\n  /**\n   * Create workflow from template\n   */\n  async createFromTemplate(\n    templateId: string,\n    params: Record<string, unknown>\n  ): Promise<WorkflowDefinition> {\n    const response = await this.client.post<WorkflowDefinition>(\n      `/api/v1/workflows/templates/${templateId}/instantiate`,\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to create workflow from template',\n        'TEMPLATE_FAILED'\n      );\n    }\n\n    return response.data;\n  }\n\n  /**\n   * List available templates\n   */\n  async listTemplates(): Promise<\n    PaginatedResponse<{ id: string; name: string; description: string }>\n  > {\n    const response = await this.client.paginate<{\n      id: string;\n      name: string;\n      description: string;\n    }>('/api/v1/workflows/templates');\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list templates', 'LIST_TEMPLATES_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Parse execution response to ensure proper types\n   */\n  private parseExecution(data: WorkflowExecution): WorkflowExecution {\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      updatedAt: new Date(data.updatedAt),\n      startedAt: data.startedAt ? new Date(data.startedAt) : undefined,\n      completedAt: data.completedAt ? new Date(data.completedAt) : undefined,\n    };\n  }\n}\n\nexport default WorkflowsClient;\n","/**\n * Context API client\n */\n\nimport { HttpClient, CopilotError } from '../client';\nimport type {\n  ContextItem,\n  ContextSearchParams,\n  ContextSearchResult,\n  DocumentInput,\n  IngestedDocument,\n  DocumentChunk,\n  PaginatedResponse,\n  PaginationParams,\n} from '../types';\n\n/**\n * Context search options\n */\ninterface SearchOptions extends ContextSearchParams {\n  /** Include vector scores in results */\n  includeScores?: boolean;\n  /** Use hybrid search (vector + keyword) */\n  hybrid?: boolean;\n  /** Rerank results */\n  rerank?: boolean;\n}\n\n/**\n * Document ingestion options\n */\ninterface IngestionOptions {\n  /** Chunking strategy */\n  chunkingStrategy?: 'fixed' | 'sentence' | 'paragraph' | 'recursive';\n  /** Target chunk size in tokens */\n  chunkSize?: number;\n  /** Overlap between chunks */\n  chunkOverlap?: number;\n  /** Generate embeddings */\n  generateEmbeddings?: boolean;\n  /** Wait for processing to complete */\n  waitForCompletion?: boolean;\n}\n\n/**\n * Context API client\n */\nexport class ContextClient {\n  constructor(private readonly client: HttpClient) {}\n\n  // ============================================================================\n  // Context Search\n  // ============================================================================\n\n  /**\n   * Search context\n   */\n  async search(options: SearchOptions): Promise<ContextSearchResult> {\n    const response = await this.client.post<ContextSearchResult>(\n      '/api/v1/context/search',\n      options\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Search failed', 'SEARCH_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Vector similarity search\n   */\n  async vectorSearch(\n    query: string,\n    options: { limit?: number; threshold?: number } = {}\n  ): Promise<ContextItem[]> {\n    const result = await this.search({\n      query,\n      ...options,\n      hybrid: false,\n    });\n\n    return result.items;\n  }\n\n  /**\n   * Hybrid search (vector + keyword)\n   */\n  async hybridSearch(\n    query: string,\n    options: {\n      limit?: number;\n      threshold?: number;\n      vectorWeight?: number;\n      keywordWeight?: number;\n    } = {}\n  ): Promise<ContextItem[]> {\n    const result = await this.search({\n      query,\n      limit: options.limit,\n      threshold: options.threshold,\n      hybrid: true,\n      filters: {\n        vectorWeight: options.vectorWeight ?? 0.7,\n        keywordWeight: options.keywordWeight ?? 0.3,\n      },\n    });\n\n    return result.items;\n  }\n\n  /**\n   * Search with reranking\n   */\n  async searchWithRerank(\n    query: string,\n    options: { limit?: number; initialLimit?: number } = {}\n  ): Promise<ContextItem[]> {\n    const result = await this.search({\n      query,\n      limit: options.limit ?? 10,\n      filters: {\n        initialLimit: options.initialLimit ?? 50,\n      },\n      rerank: true,\n    });\n\n    return result.items;\n  }\n\n  // ============================================================================\n  // Memory Management\n  // ============================================================================\n\n  /**\n   * Store a memory item\n   */\n  async storeMemory(\n    content: string,\n    options: {\n      type?: 'short_term' | 'long_term' | 'episodic';\n      importance?: number;\n      metadata?: Record<string, unknown>;\n    } = {}\n  ): Promise<ContextItem> {\n    const response = await this.client.post<ContextItem>('/api/v1/context/memory', {\n      content,\n      ...options,\n    });\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to store memory', 'STORE_MEMORY_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Get memory by ID\n   */\n  async getMemory(memoryId: string): Promise<ContextItem> {\n    const response = await this.client.get<ContextItem>(\n      `/api/v1/context/memory/${memoryId}`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Memory not found', 'NOT_FOUND', 404);\n    }\n\n    return response.data;\n  }\n\n  /**\n   * List memories\n   */\n  async listMemories(\n    params?: PaginationParams & { type?: string }\n  ): Promise<PaginatedResponse<ContextItem>> {\n    const response = await this.client.paginate<ContextItem>(\n      '/api/v1/context/memory',\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list memories', 'LIST_MEMORIES_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Delete a memory\n   */\n  async deleteMemory(memoryId: string): Promise<void> {\n    const response = await this.client.delete(`/api/v1/context/memory/${memoryId}`);\n\n    if (!response.success) {\n      throw new CopilotError('Failed to delete memory', 'DELETE_MEMORY_FAILED');\n    }\n  }\n\n  /**\n   * Consolidate memories\n   */\n  async consolidateMemories(): Promise<{ consolidated: number; remaining: number }> {\n    const response = await this.client.post<{\n      consolidated: number;\n      remaining: number;\n    }>('/api/v1/context/memory/consolidate');\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to consolidate memories',\n        'CONSOLIDATE_FAILED'\n      );\n    }\n\n    return response.data;\n  }\n\n  // ============================================================================\n  // Document Ingestion\n  // ============================================================================\n\n  /**\n   * Ingest a document\n   */\n  async ingestDocument(\n    input: DocumentInput,\n    options: IngestionOptions = {}\n  ): Promise<IngestedDocument> {\n    const { waitForCompletion = false, ...ingestionOptions } = options;\n\n    // Prepare form data for file upload\n    const formData = new FormData();\n\n    if (typeof input.content === 'string') {\n      formData.append('content', input.content);\n    } else {\n      // Convert Buffer to Uint8Array for Blob compatibility\n      const arrayBuffer = input.content instanceof ArrayBuffer\n        ? input.content\n        : new Uint8Array(input.content as Buffer);\n      formData.append(\n        'file',\n        new Blob([arrayBuffer]),\n        input.filename ?? 'document'\n      );\n    }\n\n    if (input.filename) {\n      formData.append('filename', input.filename);\n    }\n    if (input.contentType) {\n      formData.append('contentType', input.contentType);\n    }\n    if (input.metadata) {\n      formData.append('metadata', JSON.stringify(input.metadata));\n    }\n\n    Object.entries(ingestionOptions).forEach(([key, value]) => {\n      if (value !== undefined) {\n        formData.append(key, String(value));\n      }\n    });\n\n    // Note: In a real implementation, we'd need to handle FormData differently\n    const response = await this.client.post<IngestedDocument>(\n      '/api/v1/context/documents',\n      { ...input, ...ingestionOptions }\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to ingest document', 'INGESTION_FAILED');\n    }\n\n    if (waitForCompletion) {\n      return this.waitForIngestion(response.data.id);\n    }\n\n    return this.parseDocument(response.data);\n  }\n\n  /**\n   * Ingest multiple documents\n   */\n  async ingestDocuments(\n    inputs: DocumentInput[],\n    options: IngestionOptions = {}\n  ): Promise<IngestedDocument[]> {\n    const results = await Promise.all(\n      inputs.map((input) => this.ingestDocument(input, options))\n    );\n\n    return results;\n  }\n\n  /**\n   * Get document by ID\n   */\n  async getDocument(documentId: string): Promise<IngestedDocument> {\n    const response = await this.client.get<IngestedDocument>(\n      `/api/v1/context/documents/${documentId}`\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Document not found', 'NOT_FOUND', 404);\n    }\n\n    return this.parseDocument(response.data);\n  }\n\n  /**\n   * List documents\n   */\n  async listDocuments(\n    params?: PaginationParams & { status?: string }\n  ): Promise<PaginatedResponse<IngestedDocument>> {\n    const response = await this.client.paginate<IngestedDocument>(\n      '/api/v1/context/documents',\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to list documents', 'LIST_DOCUMENTS_FAILED');\n    }\n\n    return {\n      ...response.data,\n      items: response.data.items.map((d) => this.parseDocument(d)),\n    };\n  }\n\n  /**\n   * Delete a document\n   */\n  async deleteDocument(documentId: string): Promise<void> {\n    const response = await this.client.delete(\n      `/api/v1/context/documents/${documentId}`\n    );\n\n    if (!response.success) {\n      throw new CopilotError('Failed to delete document', 'DELETE_DOCUMENT_FAILED');\n    }\n  }\n\n  /**\n   * Get document chunks\n   */\n  async getDocumentChunks(\n    documentId: string,\n    params?: PaginationParams\n  ): Promise<PaginatedResponse<DocumentChunk>> {\n    const response = await this.client.paginate<DocumentChunk>(\n      `/api/v1/context/documents/${documentId}/chunks`,\n      params\n    );\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to get document chunks', 'GET_CHUNKS_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Wait for document ingestion to complete\n   */\n  async waitForIngestion(\n    documentId: string,\n    options: { pollInterval?: number; timeout?: number } = {}\n  ): Promise<IngestedDocument> {\n    const { pollInterval = 1000, timeout = 300000 } = options;\n    const startTime = Date.now();\n\n    while (true) {\n      const document = await this.getDocument(documentId);\n\n      if (document.status === 'completed' || document.status === 'failed') {\n        return document;\n      }\n\n      if (Date.now() - startTime > timeout) {\n        throw new CopilotError('Document ingestion timeout', 'INGESTION_TIMEOUT');\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, pollInterval));\n    }\n  }\n\n  // ============================================================================\n  // Context Window Management\n  // ============================================================================\n\n  /**\n   * Build context window for a query\n   */\n  async buildContextWindow(\n    query: string,\n    options: {\n      maxTokens?: number;\n      includeMemory?: boolean;\n      includeDocuments?: boolean;\n      filters?: Record<string, unknown>;\n    } = {}\n  ): Promise<{ items: ContextItem[]; totalTokens: number }> {\n    const response = await this.client.post<{\n      items: ContextItem[];\n      totalTokens: number;\n    }>('/api/v1/context/window', {\n      query,\n      ...options,\n    });\n\n    if (!response.success || !response.data) {\n      throw new CopilotError(\n        'Failed to build context window',\n        'BUILD_WINDOW_FAILED'\n      );\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Compress context to fit token budget\n   */\n  async compressContext(\n    items: ContextItem[],\n    maxTokens: number\n  ): Promise<{ items: ContextItem[]; totalTokens: number }> {\n    const response = await this.client.post<{\n      items: ContextItem[];\n      totalTokens: number;\n    }>('/api/v1/context/compress', {\n      items,\n      maxTokens,\n    });\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to compress context', 'COMPRESS_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Parse document response to ensure proper types\n   */\n  private parseDocument(data: IngestedDocument): IngestedDocument {\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      updatedAt: new Date(data.updatedAt),\n    };\n  }\n}\n\nexport default ContextClient;\n","/**\n * Core type definitions for the LLM-CoPilot SDK\n */\n\n// ============================================================================\n// Configuration Types\n// ============================================================================\n\n/**\n * SDK Configuration options\n */\nexport interface CopilotConfig {\n  /** API base URL */\n  baseUrl: string;\n  /** API key for authentication */\n  apiKey: string;\n  /** Tenant ID for multi-tenant deployments */\n  tenantId?: string;\n  /** Request timeout in milliseconds */\n  timeout?: number;\n  /** Maximum number of retries for failed requests */\n  maxRetries?: number;\n  /** Custom headers to include in all requests */\n  headers?: Record<string, string>;\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\n/**\n * Default configuration values\n */\nexport const DEFAULT_CONFIG: Partial<CopilotConfig> = {\n  timeout: 30000,\n  maxRetries: 3,\n  debug: false,\n};\n\n// ============================================================================\n// API Response Types\n// ============================================================================\n\n/**\n * Standard API response wrapper\n */\nexport interface ApiResponse<T> {\n  success: boolean;\n  data?: T;\n  error?: ApiError;\n  metadata?: ResponseMetadata;\n}\n\n/**\n * API error structure\n */\nexport interface ApiError {\n  code: string;\n  message: string;\n  details?: Record<string, unknown>;\n  requestId?: string;\n}\n\n/**\n * Response metadata\n */\nexport interface ResponseMetadata {\n  requestId: string;\n  processingTimeMs: number;\n  rateLimit?: RateLimitInfo;\n}\n\n/**\n * Rate limit information\n */\nexport interface RateLimitInfo {\n  limit: number;\n  remaining: number;\n  resetAt: Date;\n}\n\n// ============================================================================\n// Pagination Types\n// ============================================================================\n\n/**\n * Pagination parameters\n */\nexport interface PaginationParams {\n  page?: number;\n  pageSize?: number;\n  cursor?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Paginated response\n */\nexport interface PaginatedResponse<T> {\n  items: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n  hasMore: boolean;\n  nextCursor?: string;\n}\n\n// ============================================================================\n// Common Entity Types\n// ============================================================================\n\n/**\n * Base entity with common fields\n */\nexport interface BaseEntity {\n  id: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n/**\n * Entity with soft delete support\n */\nexport interface SoftDeletableEntity extends BaseEntity {\n  deletedAt?: Date;\n  isDeleted: boolean;\n}\n\n// ============================================================================\n// Message Types\n// ============================================================================\n\n/**\n * Role of a message sender\n */\nexport type MessageRole = 'user' | 'assistant' | 'system' | 'function';\n\n/**\n * A chat message\n */\nexport interface Message {\n  id: string;\n  role: MessageRole;\n  content: string;\n  metadata?: Record<string, unknown>;\n  createdAt: Date;\n  tokens?: number;\n}\n\n/**\n * Message input for creating new messages\n */\nexport interface MessageInput {\n  role: MessageRole;\n  content: string;\n  metadata?: Record<string, unknown>;\n}\n\n// ============================================================================\n// Conversation Types\n// ============================================================================\n\n/**\n * Conversation status\n */\nexport type ConversationStatus = 'active' | 'paused' | 'completed' | 'archived';\n\n/**\n * A conversation thread\n */\nexport interface Conversation extends BaseEntity {\n  title?: string;\n  status: ConversationStatus;\n  messages: Message[];\n  metadata?: Record<string, unknown>;\n  tokenCount: number;\n  messageCount: number;\n}\n\n/**\n * Input for creating a conversation\n */\nexport interface CreateConversationInput {\n  title?: string;\n  metadata?: Record<string, unknown>;\n  initialMessages?: MessageInput[];\n}\n\n/**\n * Options for sending a message\n */\nexport interface SendMessageOptions {\n  /** Enable streaming response */\n  stream?: boolean;\n  /** Temperature for generation */\n  temperature?: number;\n  /** Maximum tokens to generate */\n  maxTokens?: number;\n  /** Stop sequences */\n  stopSequences?: string[];\n  /** Additional context to include */\n  context?: ContextItem[];\n}\n\n// ============================================================================\n// Context Types\n// ============================================================================\n\n/**\n * Context item for providing additional information\n */\nexport interface ContextItem {\n  id: string;\n  type: 'document' | 'memory' | 'snippet' | 'custom';\n  content: string;\n  metadata?: Record<string, unknown>;\n  relevanceScore?: number;\n}\n\n/**\n * Context search parameters\n */\nexport interface ContextSearchParams {\n  query: string;\n  limit?: number;\n  threshold?: number;\n  filters?: Record<string, unknown>;\n}\n\n/**\n * Context search result\n */\nexport interface ContextSearchResult {\n  items: ContextItem[];\n  totalMatches: number;\n  searchTimeMs: number;\n}\n\n// ============================================================================\n// Workflow Types\n// ============================================================================\n\n/**\n * Workflow status\n */\nexport type WorkflowStatus =\n  | 'pending'\n  | 'running'\n  | 'completed'\n  | 'failed'\n  | 'cancelled'\n  | 'paused';\n\n/**\n * Workflow step action type\n */\nexport type StepActionType =\n  | 'prompt'\n  | 'tool'\n  | 'condition'\n  | 'parallel'\n  | 'loop'\n  | 'wait'\n  | 'custom';\n\n/**\n * Workflow step definition\n */\nexport interface WorkflowStep {\n  id: string;\n  name: string;\n  description?: string;\n  action: StepActionType;\n  config: Record<string, unknown>;\n  dependsOn?: string[];\n  retryConfig?: RetryConfig;\n  timeoutSeconds?: number;\n}\n\n/**\n * Retry configuration\n */\nexport interface RetryConfig {\n  maxRetries: number;\n  initialDelayMs: number;\n  maxDelayMs: number;\n  backoffMultiplier: number;\n}\n\n/**\n * Workflow definition\n */\nexport interface WorkflowDefinition {\n  id: string;\n  name: string;\n  description?: string;\n  version: string;\n  steps: WorkflowStep[];\n  triggers?: WorkflowTrigger[];\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Workflow trigger\n */\nexport interface WorkflowTrigger {\n  type: 'manual' | 'schedule' | 'event' | 'webhook';\n  config: Record<string, unknown>;\n}\n\n/**\n * Workflow execution\n */\nexport interface WorkflowExecution extends BaseEntity {\n  workflowId: string;\n  status: WorkflowStatus;\n  input?: Record<string, unknown>;\n  output?: Record<string, unknown>;\n  currentStep?: string;\n  stepResults: Record<string, StepResult>;\n  error?: string;\n  startedAt?: Date;\n  completedAt?: Date;\n  durationMs?: number;\n}\n\n/**\n * Result of a workflow step execution\n */\nexport interface StepResult {\n  stepId: string;\n  status: WorkflowStatus;\n  output?: unknown;\n  error?: string;\n  startedAt: Date;\n  completedAt?: Date;\n  durationMs?: number;\n  retryCount?: number;\n}\n\n/**\n * Input for creating a workflow\n */\nexport interface CreateWorkflowInput {\n  name: string;\n  description?: string;\n  steps: Omit<WorkflowStep, 'id'>[];\n  triggers?: WorkflowTrigger[];\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Input for executing a workflow\n */\nexport interface ExecuteWorkflowInput {\n  workflowId: string;\n  input?: Record<string, unknown>;\n  async?: boolean;\n}\n\n// ============================================================================\n// Streaming Types\n// ============================================================================\n\n/**\n * Streaming event types\n */\nexport type StreamEventType =\n  | 'message_start'\n  | 'content_delta'\n  | 'content_stop'\n  | 'message_stop'\n  | 'error'\n  | 'tool_use'\n  | 'tool_result';\n\n/**\n * Base streaming event\n */\nexport interface StreamEvent<T = unknown> {\n  type: StreamEventType;\n  data: T;\n  timestamp: Date;\n}\n\n/**\n * Content delta in streaming\n */\nexport interface ContentDelta {\n  text: string;\n  index: number;\n}\n\n/**\n * Streaming options\n */\nexport interface StreamOptions {\n  /** Callback for each chunk */\n  onChunk?: (chunk: string) => void;\n  /** Callback for events */\n  onEvent?: (event: StreamEvent) => void;\n  /** Callback for errors */\n  onError?: (error: Error) => void;\n  /** Callback when stream completes */\n  onComplete?: (message: Message) => void;\n  /** Signal for aborting the stream */\n  signal?: AbortSignal;\n}\n\n// ============================================================================\n// Document Ingestion Types\n// ============================================================================\n\n/**\n * Supported document types\n */\nexport type DocumentType =\n  | 'text'\n  | 'markdown'\n  | 'pdf'\n  | 'html'\n  | 'json'\n  | 'code';\n\n/**\n * Document for ingestion\n */\nexport interface DocumentInput {\n  content: string | Buffer;\n  filename?: string;\n  contentType?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Ingested document\n */\nexport interface IngestedDocument extends BaseEntity {\n  filename?: string;\n  contentType: string;\n  size: number;\n  chunkCount: number;\n  status: 'processing' | 'completed' | 'failed';\n  error?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Document chunk\n */\nexport interface DocumentChunk {\n  id: string;\n  documentId: string;\n  content: string;\n  index: number;\n  tokenCount: number;\n  metadata?: Record<string, unknown>;\n}\n\n// ============================================================================\n// Webhook Types\n// ============================================================================\n\n/**\n * Webhook event types\n */\nexport type WebhookEventType =\n  | 'conversation.created'\n  | 'conversation.updated'\n  | 'message.created'\n  | 'workflow.started'\n  | 'workflow.completed'\n  | 'workflow.failed'\n  | 'document.ingested';\n\n/**\n * Webhook configuration\n */\nexport interface WebhookConfig {\n  id: string;\n  url: string;\n  events: WebhookEventType[];\n  secret: string;\n  isActive: boolean;\n  createdAt: Date;\n}\n\n/**\n * Webhook payload\n */\nexport interface WebhookPayload<T = unknown> {\n  id: string;\n  type: WebhookEventType;\n  timestamp: Date;\n  data: T;\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Make all properties of T optional recursively\n */\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n/**\n * Extract the resolved type from a Promise\n */\nexport type Awaited<T> = T extends Promise<infer U> ? U : T;\n\n/**\n * Callback type for event handlers\n */\nexport type EventHandler<T = void> = (data: T) => void | Promise<void>;\n","/**\n * LLM-CoPilot TypeScript SDK\n *\n * A comprehensive SDK for interacting with the LLM-CoPilot-Agent API.\n *\n * @example\n * ```typescript\n * import { CopilotClient } from '@llm-copilot/sdk';\n *\n * const client = new CopilotClient({\n *   baseUrl: 'https://api.copilot.example.com',\n *   apiKey: 'your-api-key',\n * });\n *\n * // Create a conversation and send messages\n * const conversation = await client.conversations.create();\n * const response = await client.conversations.sendMessage(\n *   conversation.id,\n *   'Hello, world!'\n * );\n *\n * // Stream responses\n * await client.conversations.streamMessage(\n *   conversation.id,\n *   'Tell me a story',\n *   {\n *     onChunk: (chunk) => process.stdout.write(chunk),\n *   }\n * );\n *\n * // Search context\n * const results = await client.context.search({\n *   query: 'important topic',\n *   limit: 10,\n * });\n *\n * // Execute workflows\n * const execution = await client.workflows.execute({\n *   workflowId: 'my-workflow',\n *   input: { data: 'value' },\n * });\n * ```\n */\n\nimport { HttpClient, CopilotError } from './client';\nimport { ConversationsClient } from './conversations';\nimport { WorkflowsClient } from './workflows';\nimport { ContextClient } from './context';\nimport type { CopilotConfig } from './types';\n\n// Re-export types\nexport * from './types';\nexport { CopilotError } from './client';\n\n/**\n * Main SDK client\n */\nexport class CopilotClient {\n  private readonly httpClient: HttpClient;\n\n  /** Conversations API */\n  public readonly conversations: ConversationsClient;\n\n  /** Workflows API */\n  public readonly workflows: WorkflowsClient;\n\n  /** Context API */\n  public readonly context: ContextClient;\n\n  constructor(config: CopilotConfig) {\n    this.httpClient = new HttpClient(config);\n    this.conversations = new ConversationsClient(this.httpClient);\n    this.workflows = new WorkflowsClient(this.httpClient);\n    this.context = new ContextClient(this.httpClient);\n  }\n\n  /**\n   * Create a client from environment variables\n   */\n  static fromEnv(overrides?: Partial<CopilotConfig>): CopilotClient {\n    const baseUrl =\n      overrides?.baseUrl ??\n      process.env['COPILOT_API_URL'] ??\n      process.env['COPILOT_BASE_URL'];\n\n    const apiKey =\n      overrides?.apiKey ??\n      process.env['COPILOT_API_KEY'];\n\n    const tenantId =\n      overrides?.tenantId ??\n      process.env['COPILOT_TENANT_ID'];\n\n    if (!baseUrl) {\n      throw new CopilotError(\n        'Missing API URL. Set COPILOT_API_URL environment variable or pass baseUrl in config.',\n        'CONFIG_ERROR'\n      );\n    }\n\n    if (!apiKey) {\n      throw new CopilotError(\n        'Missing API key. Set COPILOT_API_KEY environment variable or pass apiKey in config.',\n        'CONFIG_ERROR'\n      );\n    }\n\n    return new CopilotClient({\n      baseUrl,\n      apiKey,\n      tenantId,\n      ...overrides,\n    });\n  }\n\n  /**\n   * Get SDK version\n   */\n  static get version(): string {\n    return '0.1.0';\n  }\n\n  /**\n   * Health check\n   */\n  async healthCheck(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    version: string;\n    services: Record<string, boolean>;\n  }> {\n    const response = await this.httpClient.get<{\n      status: 'healthy' | 'degraded' | 'unhealthy';\n      version: string;\n      services: Record<string, boolean>;\n    }>('/health');\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Health check failed', 'HEALTH_CHECK_FAILED');\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Get API info\n   */\n  async getApiInfo(): Promise<{\n    name: string;\n    version: string;\n    description: string;\n    documentation: string;\n  }> {\n    const response = await this.httpClient.get<{\n      name: string;\n      version: string;\n      description: string;\n      documentation: string;\n    }>('/api/v1');\n\n    if (!response.success || !response.data) {\n      throw new CopilotError('Failed to get API info', 'API_INFO_FAILED');\n    }\n\n    return response.data;\n  }\n}\n\n// Default export\nexport default CopilotClient;\n\n// Named exports for tree-shaking\nexport { ConversationsClient } from './conversations';\nexport { WorkflowsClient } from './workflows';\nexport { ContextClient } from './context';\nexport { HttpClient } from './client';\n"]}